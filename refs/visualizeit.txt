Directory structure:
└── visualize-it-visualize-it.github.io/
    ├── README.md
    ├── about.html
    ├── google822fdce5e4527846.html
    ├── helper.js
    ├── index.html
    ├── index.js
    ├── style.css
    ├── ant_colony_optimization/
    │   ├── basic.js
    │   ├── render.js
    │   ├── simulation.html
    │   ├── simulation.js
    │   └── user_input.js
    ├── artificial_life/
    │   ├── basic.js
    │   ├── Particle.js
    │   ├── simulation.html
    │   ├── simulation.js
    │   └── user_input.js
    ├── bernoulli_percolation/
    │   ├── basic.js
    │   ├── simulation.html
    │   ├── simulation.js
    │   └── user_input.js
    ├── bezier_curves/
    │   ├── basic.js
    │   ├── bezier_curves.js
    │   ├── patterns.js
    │   ├── Point.js
    │   └── simulation.html
    ├── clustering/
    │   ├── basic.js
    │   ├── simulation.html
    │   ├── simulation.js
    │   └── user_input.js
    ├── collatz_conjecture/
    │   ├── basic.js
    │   ├── collatz_conjecture.js
    │   └── simulation.html
    ├── collective_behaviour/
    │   ├── basic.js
    │   ├── Boid.js
    │   ├── predefs.js
    │   ├── simulation.html
    │   ├── simulation.js
    │   ├── tests.js
    │   ├── user_input.js
    │   ├── utils.js
    │   └── Vector.js
    ├── conic_sections/
    │   ├── basic.js
    │   ├── conic_sections.js
    │   └── simulation.html
    ├── contact_process/
    │   ├── basic.js
    │   ├── contact_process.js
    │   ├── simulation.html
    │   └── user_input.js
    ├── conway_game/
    │   ├── basic.js
    │   ├── conway_game.js
    │   ├── engine.js
    │   ├── predef.js
    │   ├── simulation.html
    │   └── utils.js
    ├── couzin_model/
    │   ├── basic.js
    │   ├── Boid.js
    │   ├── predefs.js
    │   ├── simulation.html
    │   ├── simulation.js
    │   ├── tests.js
    │   ├── user_input.js
    │   ├── utils.js
    │   └── Vector.js
    ├── double_pendulum/
    │   ├── basic.js
    │   ├── pendulum.js
    │   ├── simulation.html
    │   ├── simulation.js
    │   └── user_input.js
    ├── firefly_synchronization/
    │   ├── basic.js
    │   ├── Emit.js
    │   ├── Firefly.js
    │   ├── simulation.html
    │   ├── simulation.js
    │   ├── user_input.js
    │   ├── utils.js
    │   └── Vector.js
    ├── flocking_behaviour/
    │   ├── basic.js
    │   ├── flocking_behaviour.js
    │   └── simulation.html
    ├── flocking_demonstration/
    │   ├── basic.js
    │   ├── Boid.js
    │   ├── simulation.html
    │   ├── simulation.js
    │   ├── tests.js
    │   ├── user_input.js
    │   ├── utils.js
    │   └── Vector.js
    ├── flocking_game/
    │   ├── boid.js
    │   ├── frequency.js
    │   ├── histograms.js
    │   ├── linker.js
    │   ├── math.js
    │   ├── simulation.html
    │   ├── simulator.js
    │   └── style.css
    ├── flocking_simulation/
    │   ├── basic.js
    │   ├── Boid.js
    │   ├── simulation.html
    │   ├── simulation.js
    │   ├── tests.js
    │   ├── user_input.js
    │   ├── utils.js
    │   └── Vector.js
    ├── fonts/
    │   ├── Merriweather-Regular.ttf
    │   ├── Montserrat-Regular.ttf
    │   ├── Roboto-Regular.ttf
    │   └── SofiaSans-Medium.ttf
    ├── fourier_series/
    │   ├── basic.js
    │   ├── simulation.html
    │   ├── simulation.js
    │   └── user_input.js
    ├── gradient_descent/
    │   ├── basic.js
    │   ├── simulation.html
    │   ├── simulation.js
    │   └── user_input.js
    ├── heat_equation/
    │   ├── basic.js
    │   ├── heat_equation.js
    │   └── simulation.html
    ├── hilbert_curve/
    │   ├── basic.js
    │   ├── hilbert_curve.js
    │   └── simulation.html
    ├── home_range/
    │   ├── Animal.js
    │   ├── basic.js
    │   ├── Gene.js
    │   ├── Murder.js
    │   ├── Predator.js
    │   ├── selection.js
    │   ├── simulation.html
    │   ├── simulation.js
    │   └── user_input.js
    ├── hopfield_networks/
    │   ├── basic.js
    │   ├── simulation.html
    │   ├── simulation.js
    │   └── user_input.js
    ├── image_filters/
    │   ├── basic.js
    │   ├── simulation.html
    │   ├── simulation.js
    │   └── user_input.js
    ├── images_webp/
    │   ├── ant_colony.webp
    │   ├── bernoulli_percolation.webp
    │   ├── bezier_curves.webp
    │   ├── clustering.webp
    │   ├── collatz_conjecture.webp
    │   ├── collective_behaviour.webp
    │   ├── contact_process.webp
    │   ├── conways_game.webp
    │   ├── double_pendulum.webp
    │   ├── firefly_sync.webp
    │   ├── fourier.webp
    │   ├── genetic_algo.webp
    │   ├── gradient_descent.webp
    │   ├── hilbert_curve.webp
    │   ├── hopfield.webp
    │   ├── image_filters.webp
    │   ├── ising_model.webp
    │   ├── lexical_analysis.webp
    │   ├── linear_momentum.webp
    │   ├── linear_transformations.webp
    │   ├── lorenz_system.webp
    │   ├── lotka_volterra.webp
    │   ├── mandelbrot_fractal.webp
    │   ├── maze_generation.webp
    │   ├── monte_carlo.webp
    │   ├── nuclear_fusion.webp
    │   ├── pedestrian_dynamics.webp
    │   ├── planetary_motion.webp
    │   ├── polynomial_regression.webp
    │   ├── porous_percolation.webp
    │   ├── projectile_motion.webp
    │   ├── public_goods.webp
    │   ├── quantum_computing.webp
    │   ├── random_walks.webp
    │   ├── reaction_diffusion.webp
    │   ├── schelling_model.webp
    │   ├── simple_fluid.webp
    │   ├── small_world_networks.webp
    │   ├── sorting_algos.webp
    │   ├── special_relativity.webp
    │   ├── spring_motion.webp
    │   ├── stroboscopic_effect.webp
    │   ├── tdp.webp
    │   ├── travelling_salesman.webp
    │   ├── trig_functions.webp
    │   └── vicsek_model.webp
    ├── ising_model/
    │   ├── basic.js
    │   ├── simulation.html
    │   ├── simulation.js
    │   └── user_input.js
    ├── lexical_analysis/
    │   ├── basic.js
    │   ├── lexical_analysis.js
    │   └── simulation.html
    ├── linear_momentum/
    │   ├── basic.js
    │   ├── linear_momentum.js
    │   ├── simulation.html
    │   └── user_input.js
    ├── linear_transformations/
    │   ├── basic.js
    │   ├── linear_transformations.js
    │   └── simulation.html
    ├── lorenz_system/
    │   ├── basic.js
    │   ├── lorenz_system.js
    │   └── simulation.html
    ├── lotka_volterra/
    │   ├── basic.js
    │   ├── simulation.html
    │   ├── simulation.js
    │   └── user_input.js
    ├── mandelbrot_fractal/
    │   ├── basic.js
    │   ├── mandelbrot_fractal.js
    │   └── simulation.html
    ├── marching_squares/
    │   ├── basic.js
    │   ├── simulation.html
    │   ├── simulation.js
    │   └── user_input.js
    ├── maze_generation/
    │   ├── basic.js
    │   ├── Cell.js
    │   ├── dfs.js
    │   ├── kruskal.js
    │   ├── maze_generation.js
    │   ├── NakedCell.js
    │   ├── prim.js
    │   ├── simulation.html
    │   └── Wall.js
    ├── monte_carlo/
    │   ├── basic.js
    │   ├── simulation.html
    │   ├── simulation.js
    │   └── user_input.js
    ├── natural_selection/
    │   ├── basic.js
    │   ├── Boid.js
    │   ├── Gene.js
    │   ├── natural_selection.js
    │   ├── simulation.html
    │   ├── Source.js
    │   ├── Target.js
    │   ├── user_input.js
    │   └── Wall.js
    ├── nuclear_fusion/
    │   ├── basic.js
    │   ├── core.js
    │   ├── diffusion.js
    │   ├── Fusion_event.js
    │   ├── Nucleus.js
    │   ├── renderers.js
    │   ├── simulation.html
    │   └── user_input.js
    ├── pedestrian_dynamics/
    │   ├── basic.js
    │   ├── Boid.js
    │   ├── simulation.html
    │   ├── simulation.js
    │   ├── user_input.js
    │   └── Vector.js
    ├── planetary_motion/
    │   ├── basic.js
    │   ├── planetary_motion.js
    │   └── simulation.html
    ├── polynomial_regression/
    │   ├── basic.js
    │   ├── polynomial_regression.js
    │   ├── simulation.html
    │   └── user_input.js
    ├── porous_percolation/
    │   ├── basic.js
    │   ├── simulation.html
    │   ├── simulation.js
    │   └── user_input.js
    ├── predator_escape/
    │   ├── basic.js
    │   ├── Boid.js
    │   ├── predefs.js
    │   ├── simulation.html
    │   ├── simulation.js
    │   ├── tests.js
    │   ├── user_input.js
    │   ├── utils.js
    │   └── Vector.js
    ├── projectile_motion/
    │   ├── basic.js
    │   ├── projectile.js
    │   └── simulation.html
    ├── public_goods/
    │   ├── basic.js
    │   ├── simulation.html
    │   ├── simulation.js
    │   └── user_input.js
    ├── quantum_logic/
    │   ├── basic.js
    │   ├── quantum_logic.js
    │   └── simulation.html
    ├── random_walk/
    │   ├── Animal.js
    │   ├── basic.js
    │   ├── graph.js
    │   ├── random_walk.js
    │   └── simulation.html
    ├── reaction_diffusion/
    │   ├── basic.js
    │   ├── misc.js
    │   ├── patterns.js
    │   ├── reaction_diffusion.js
    │   └── simulation.html
    ├── sandpile_model/
    │   ├── basic.js
    │   ├── simulation.html
    │   ├── simulation.js
    │   └── user_input.js
    ├── schelling_model/
    │   ├── basic.js
    │   ├── Boid.js
    │   ├── simulation.html
    │   ├── simulation.js
    │   ├── user_input.js
    │   └── utils.js
    ├── simple_fluid/
    │   ├── basic.js
    │   ├── engine.js
    │   ├── main.js
    │   ├── render.js
    │   ├── simulation.html
    │   └── user_input.js
    ├── small_world_networks/
    │   ├── basic.js
    │   ├── Edge.js
    │   ├── Node.js
    │   ├── simulation.html
    │   ├── simulation.js
    │   └── user_input.js
    ├── sorting_algos/
    │   ├── basic.js
    │   ├── bubble_sort.js
    │   ├── cocktail_shaker_sort.js
    │   ├── Heap.js
    │   ├── heap_sort.js
    │   ├── insertion_sort.js
    │   ├── merge_sort.js
    │   ├── quick_sort.js
    │   ├── selection_sort.js
    │   ├── simulation.html
    │   ├── sorting_algos.js
    │   └── user_input.js
    ├── special_relativity/
    │   ├── basic.js
    │   ├── simulation.html
    │   └── special_relativity.js
    ├── spring_motion/
    │   ├── basic.js
    │   ├── simulation.html
    │   └── spring.js
    ├── stroboscopic_effect/
    │   ├── basic.js
    │   ├── simulation.html
    │   └── stroboscopic_effect.js
    ├── swarm_synchronization/
    │   ├── basic.js
    │   ├── Boid.js
    │   ├── simulation.html
    │   ├── simulation.js
    │   ├── user_input.js
    │   ├── utils.js
    │   └── Vector.js
    ├── tdp/
    │   ├── basic.js
    │   ├── simulation.html
    │   ├── simulation.js
    │   └── user_input.js
    ├── templates/
    │   ├── basic.js
    │   ├── simulation.html
    │   ├── simulation.js
    │   └── user_input.js
    ├── toner_tu/
    │   ├── basic.js
    │   ├── simulation.html
    │   ├── simulation.js
    │   ├── user_input.js
    │   └── Vector.js
    ├── travelling_salesman/
    │   ├── basic.js
    │   ├── renderers.js
    │   ├── simulation.html
    │   ├── travelling_salesman.js
    │   └── user_input.js
    ├── trig_functions/
    │   ├── multithread.js
    │   ├── sec_cosec.js
    │   ├── simulation.html
    │   ├── sin_cos.js
    │   └── tan_cot.js
    ├── vicsek_model/
    │   ├── basic.js
    │   ├── simulation.html
    │   ├── simulation.js
    │   └── user_input.js
    ├── waves/
    │   ├── basic.js
    │   ├── simulation.html
    │   ├── user_input.js
    │   └── waves.js
    └── xy_model/
        ├── basic.js
        ├── simulation.html
        ├── simulation.js
        └── user_input.js


Files Content:

(Files content cropped to 300k characters, download full ingest to see more)
================================================
FILE: README.md
================================================
# Visualize - It: View scientific concepts at work. Anytime. Anywhere

This website serves to provide an interactive learning experience for topics in the fields of physics, mathematics, computer science and complex-systems



================================================
FILE: about.html
================================================
<!DOCTYPE html>
<html lang="en-US">

<head>
  <title>About | Visualize It</title>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Materialize -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/js/materialize.min.js"></script>

  <!-- CSS -->
  <link rel="stylesheet" href="style.css" />
</head>

<script async src="https://www.googletagmanager.com/gtag/js?id=G-M95CKRP8HB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() { window.dataLayer.push(arguments); }
  gtag('js', new Date());

  gtag('config', 'G-M95CKRP8HB');
</script>

<body>
  <nav class="nav-extended" style="background:black; margin-top: 0mm">
    <div class="nav-wrapper">
      <h1 id="main-heading">Visualize It</h1>
    </div>
    <div class="nav-content">
      <ul class="tabs tabs-transparent tabs-fixed-width">
        <li class="tab"><a href="index.html" style="font-size: larger;">Home</a></li>
        <li class="tab"><a class="active" href="#" style="font-size: larger;">About</a></li>
      </ul>
    </div>
  </nav>

  <div class="container" style="width: 100%">
    <div class="row">
      <div class="s12">
        <br>
        <p class="flow-text">
          All simulations here were developed by ChanRT / Chandan Relekar. Fork me at <a
            href="https://www.github.com/chanrt">GitHub</a>!
          <br>
          Everything has been programmed using vanilla JavaScript.
          <br> <br>
          You are free to use these simulations for educational purposes.
          <br>
          However, an acknowledgement would be great!
          <br> <br>
          Many simulations on this website are inspired from the works of YouTube creators.
          <br>
          To name a few: <a target="_blank" href="https://www.youtube.com/c/TheCodingTrain">The Coding Train</a>, <a
            target="_blank" href="https://www.youtube.com/c/SebastianLague/videos">Sebastian Lague</a>, <a
            target="_blank" href="https://www.youtube.com/c/veritasium/featured">Veritasium</a>, <a target="_blank"
            href="https://www.youtube.com/c/3blue1brown/videos">3Blue1Brown</a>, <a target="_blank"
            href="https://www.youtube.com/channel/UCpCSAcbqs-sjEVfk_hMfY9w">Zach Star</a>, <a target="_blank"
            href="https://www.youtube.com/c/Reducible">Reducible</a>, <a target="_blank"
            href="https://www.youtube.com/user/Computerphile">Computerphile</a>, <a target="_blank"
            href="https://www.youtube.com/c/numberphile">Numberphile</a> and many others!
          <br>
          Certain simulations on niche topics were motivated by courses that I took at my university (<a target="_blank"
            href="https://iisc.ac.in/">Indian Institute of Science</a>).
          <br> <br>
          A lot of simulations are under development, and a new one is released every 2-3 weeks or so.
          <center>
            <div style="background:black; border: 1px solid red;">
              <p class="flow-text">
                This website was featured in top 100 worldwide of 3Blue1Brown's Summer of Math Exposition II
              </p>
            </div>
          </center>
          <br>

          <img class="responsive-img" src="assets/3b1b.png">
          <br> <br>
        </p>
        <p class="flow-text">
          This website has had almost 100,000 views since July 2021 (measured on August 2024), and has been accessed from
          countries all over the world!
        <div class="col s12 l6">
          <img class="responsive-img" src="assets/views.png">
        </div>
        <div class="col s12 l6">
          <img class="responsive-img" src="assets/world.png">
          <br>
          <br>
          <br>
        </div>
        </p>

        <h2>Timeline</h2>
        <center>
          <div style="background:black; border: 1px solid red;">
            <p class="flow-text">
              This is an ONGOING project!
            </p>
          </div>
        </center>

        <center>
          <table class="flow-text">
            <tr>
              <th>Topic</th>
              <th>Date</th>
            </tr>
            <tr>
              <td>Hopfield Networks</td>
              <td>September 8th, 2024</td>
            </tr>
            <tr>
              <td>Public Goods</td>
              <td>June 29th, 2024</td>
            </tr>
            <tr>
              <td>Small-World Networks</td>
              <td>June 4th, 2024</td>
            </tr>
            <tr>
              <td>Pedestrian Dynamics</td>
              <td>January 24th, 2024</td>
            </tr>
            <tr>
              <td>Ant Colony Optimization</td>
              <td>November 4th, 2023</td>
            </tr>
            <tr>
              <td>Predator Escape (<a href="predator_escape/simulation.html">archived</a>)</td>
              <td>March 2nd, 2024</td>
            </tr>
            <tr>
              <td>Double Pendulum</td>
              <td>February 19th, 2023</td>
            </tr>
            <tr>
              <td>Vicsek Model</td>
              <td>February 14th, 2023</td>
            </tr>
            <tr>
              <td>Porous Percolation</td>
              <td>February 12th, 2023</td>
            </tr>
            <tr>
              <td>Bernoulli Percolation</td>
              <td>February 9th, 2023</td>
            </tr>
            <tr>
              <td>Simple Fluid</td>
              <td>January 21st, 2023</td>
            </tr>
            <tr>
              <td>Fourier Series</td>
              <td>January 19th, 2023</td>
            </tr>
            <tr>
              <td>Tricritical Directed Percolation</td>
              <td>January 18th, 2023</td>
            </tr>
            <tr>
              <td>Lotka-Volterra Model</td>
              <td>October 10th, 2022</td>
            </tr>
            <tr>
              <td>Schelling's Model</td>
              <td>July 20th, 2022</td>
            </tr>
            <tr>
              <td>Gradient Descent</td>
              <td>July 18th, 2022</td>
            </tr>
            <tr>
              <td>Firefly Synchronization</td>
              <td>June 30th, 2022</td>
            </tr>
            <tr>
              <td>Ising Model</td>
              <td>June 29th, 2022</td>
            </tr>
            <tr>
              <td>Collective Behaviour</td>
              <td>June 24th, 2022</td>
            </tr>
            <tr>
              <td>Flocking Behaviour (<a href="flocking_behaviour/simulation.html">archived*</a>)</td>
              <td>June 17th, 2022</td>
            </tr>
            <tr>
              <td>Monte Carlo</td>
              <td>March 15th, 2022</td>
            </tr>
            <tr>
              <td>K-means Clustering</td>
              <td>March 15th, 2022</td>
            </tr>
            <tr>
              <td>Image Filters</td>
              <td>December 4th, 2021</td>
            </tr>
            <tr>
              <td>Home Range (<a href="home_range/simulation.html">archived</a>)</td>
              <td>November 29th, 2021</td>
            </tr>
            <tr>
              <td>Nuclear Fusion</td>
              <td>November 10th, 2021</td>
            </tr>
            <tr>
              <td>Sorting Algorithms</td>
              <td>October 7th, 2021</td>
            </tr>
            <tr>
              <td>Genetic Algorithm</td>
              <td>October 4th, 2021</td>
            </tr>
            <tr>
              <td>Polynomial Regression</td>
              <td>September 20th, 2021</td>
            </tr>
            <tr>
              <td>Contact Process</td>
              <td>September 19th, 2021</td>
            </tr>
            <tr>
              <td>Bezier Curves</td>
              <td>September 4th, 2021</td>
            </tr>
            <tr>
              <td>Reaction Diffusion</td>
              <td>August 24th, 2021</td>
            </tr>
            <tr>
              <td>Random Walks</td>
              <td>August 22nd, 2021</td>
            </tr>
            <tr>
              <td>Maze Generation</td>
              <td>August 20th, 2021</td>
            </tr>
            <tr>
              <td>Collatz Conjecture (<a href="collatz_conjecture/simulation.html">archived</a>)</td>
              <td>July 31st, 2021</td>
            </tr>
            <tr>
              <td>Prime Counting (<a href="prime_counting/simulation.html">archived)</td>
              <td>July 23rd, 2021</td>
            </tr>
            <tr>
              <td>Hilbert Curve</td>
              <td>July 23rd, 2021</td>
            </tr>
            <tr>
              <td>Lorenz System</td>
              <td>July 21st, 2021</td>
            </tr>
            <tr>
              <td>Logistic Map (<a href="bifurcation_diagram/simulation.html">archived</a>)</td>
              <td>May 20th, 2021</td>
            </tr>
            <tr>
              <td>Lexical Analysis</td>
              <td>May 17th, 2021</td>
            </tr>
            <tr>
              <td>Travelling Salesman</td>
              <td>May 14th, 2021</td>
            </tr>
            <tr>
              <td>Mandelbrot Fractal</td>
              <td>March 13th, 2021</td>
            </tr>
            <tr>
              <td>Verhulst Model (<a href="verhulst_model/simulation.html">archived</a>)</td>
              <td>March 5th, 2021</td>
            </tr>
            <tr>
              <td>Heat Equation (<a href="heat_equation/simulation.html">archived</a>)</td>
              <td>February 24th, 2021</td>
            </tr>
            <tr>
              <td>Conway's Game of Life</td>
              <td>February 7th, 2021</td>
            </tr>
            <tr>
              <td>Linear Momentum</td>
              <td>January 26th, 2021</td>
            </tr>
            <tr>
              <td>Linear Transformations</td>
              <td>January 23rd, 2021</td>
            </tr>
            <tr>
              <td>Conic sections (<a href="conic_sections/simulation.html">archived</a>)</td>
              <td>January 21st, 2021</td>
            </tr>
            <tr>
              <td>Quantum Computing</td>
              <td>January 18th, 2021</td>
            </tr>
            <tr>
              <td>Special Relativity</td>
              <td>January 7th, 2021</td>
            </tr>
            <tr>
              <td>Stroboscopic Effect</td>
              <td>December 24th, 2020</td>
            </tr>
            <tr>
              <td>Planetary Motion</td>
              <td>December 15th, 2020</td>
            </tr>
            <tr>
              <td>Projectile Motion</td>
              <td>December 10th, 2020</td>
            </tr>
            <tr>
              <td>Spring Motion</td>
              <td>December 9th, 2020</td>
            </tr>
            <tr>
              <td>Trigonometric Functions</td>
              <td>December 5th, 2020</td>
            </tr>
            <tr>
              <td>Repository created</td>
              <td>November 25th, 2020</td>
            </tr>
          </table>
          <p>
            *Certain topics here have been archived because they have been covered within an overarching topic (like
            flocking behaviour is a particular case of collective behaviour, among others). The websites for topics like
            prime counting, Collatz conjecture and conic sections are not educative enough, to be featured along with
            others.
          </p>
        </center>

        <h2>Planned Topics</h2>
        <center>
          <div style="background:black; border: 1px solid red;">
            <p class="flow-text">
              If this website gets a larger audience, then I will have greater impetus to work on these topics!
            </p>
          </div>
        </center>
        <ol class="flow-text">
          <li>Solve Travelling Salesman using Genetic Algorithm and Simulated Annealing</li>
          <li>Pattern formation in pulsed oscillators</li>
          <li>Phase-coupled Oscillators</li>
          <li>Orbits (basically, shooting balls out of a cannon at different altitudes and velocities)</li>
          <li>Artificial Life (<a href="artificial_life/simulation.html">partially completed</a>)</li>
          <li>Collapse of stars, using Lane-Emden equations</li>
          <li>Accretion disk of black holes</li>
          <li>Simulating the Wave equation (<a href="waves/simulation.html">partially completed</a>)</li>
          <li>XY model of Statistical Mechanics (<a href="xy_model/simulation.html">partially completed</a>)</li>
          <li>Beautiful patterns generated by Diffusion Limited Aggregation</li>
          <li>Famous Fractals</li>
          <li>Drawing implicit functions using Marching Squares (<a href="marching_squares/simulation.html">partially
              completed</a>)</li>
          <li>Collision detection algorithms</li>
          <li>Perlin noise (implementation not yet clear)</li>
          <li>Doppler effect</li>
          <li>Graph algorithms like Djikstra, A*, Bellmann-Ford, etc.</li>
          <li>Graph (set of nodes and edges) drawing algorithms </li>
          <li>Random Boolean Networks</li>
          <li>Fluids (specifics not yet clear)</li>
          <li>Splines and other beautiful curves (specifics not yet clear)</li>
          <li>SIR Model of Pandemic spread</li>
          <li>Boltzmann Distribution in a randomized exchange lattice</li>
          <li>Raycasting</li>
          <li>Wave function collapse (procedural level generation)</li>
          <li>Maximum flow in a network</li>
          <li>Forest fires</li>
          <li>Microbial growth patterns</li>
          <li>Power-law clustering of Vegetation</li>
          <li>Kuramoto Model</li>
          <li>Levy walk</li>
          <li>Chemotaxis</li>
          <li>Lennard Jones fluid</li>
          <li>Voter model (stochastic imitation, majority choice)</li>
          <li>Language competition (Abrams - Strogatz Model)</li>
          <li>Threshold model (complex contagion model used to describe spread of rumours and fads)</li>
          <li>Parking strategies</li>
          <li>Sandpile mode (<a href="sandpile_model/simulation.html">partially completed</a>)</li>
          <li>Toner-Tu field theory (<a href="toner_tu/simulation.html">partially completed</a>)</li>
        </ol>

        <p class="flow-text">
          Additionally, if you have any concept(s) in mind that I can simulate,
          <br>
          then please contact me via <a href="https://github.com/chanrt">GitHub</a>, email me at <a
            href="mailto:chanrt.visualize@gmail.com">chanrt.visualize@gmail.com</a> or tweet me <a
            href="https://twitter.com/_chanrt_">@_chanrt_</a>
          <br>
        </p>
        <center>
          <div style="background:black; border: 1px solid red;">
            <p class="flow-text">
              Thanks for visiting!
            </p>
          </div>
        </center>
      </div>
    </div>
  </div>
</body>

</html>


================================================
FILE: google822fdce5e4527846.html
================================================
google-site-verification: google822fdce5e4527846.html


================================================
FILE: helper.js
================================================
// DOM
function getElement(id) {
    return document.getElementById(id);
}

// Math
function getDistance(x1, y1, x2, y2) {
    return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
}

function getMagn(x, y) {
    return Math.sqrt(x * x + y * y);
}

function toRadian(degrees) {
    return degrees * Math.PI / 180;
}

function toDegree(radian) {
    return radian * 180 / Math.PI;
}

// Random 
function randInt(lower, upper) {
    return Math.floor(lower + Math.random() * (upper - lower));
}

function randomElement(array) {
    return array[Math.floor(Math.random() * array.length)]
}

function randomColor() {
    var letters = '0123456789ABCDEF';
    var color = '#';
    for (var i = 0; i < 6; i++) {
        color += letters[Math.floor(Math.random() * 16)];
    }
    return color;
}

// Clean array generation
function new1dArray(length) {
    let array = [];
    for(let i = 0; i < length; i++) {
        array.push(0);
    }
    return array;
}

function new2dArray(num_rows, num_cols) {
    let array_2d= [];
    for(let i = 0; i < num_rows; i++) {
        let array_1d = [];
        for(let j = 0; j < num_cols; j++) {
            array_1d.push(0);
        }
        array_2d.push(array_1d);
    }
    return array_2d;
}

// Array manipulation
function removeElement(array, element) {
    return array.filter(function (dummy) {
        return dummy != element;
    });
}

function shuffleKnuth(array) {
    let currentIndex = array.length, randomIndex;

    while (currentIndex != 0) {
        randomIndex = Math.floor(Math.random() * currentIndex);
        currentIndex--;

        [array[currentIndex], array[randomIndex]] = [array[randomIndex], array[currentIndex]];
    }
    return array;
}

// rgb to hex
function rgbToHex(r, g, b) {
    return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
}


================================================
FILE: index.html
================================================
<!DOCTYPE html>
<html lang="en-US">

<head>
    <title>Visualize It | Home Page</title>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="description" content="View Scientific Concepts at work. Anytime. Anywhere">
    <meta name="keywords" content="interactive, visualization, simulation, science, education">
    <meta name="google-site-verification" content="9GighFXREm-tIw0hymUa7X3tHRb1OR31qdV__bw2bwc" />

    <!-- Materialize -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/js/materialize.min.js"></script>

    <!-- Field toggle Script -->
    <script src="index.js"></script>

    <!-- CSS -->
    <link rel="stylesheet" href="style.css" />
</head>

<script async src="https://www.googletagmanager.com/gtag/js?id=G-M95CKRP8HB"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { window.dataLayer.push(arguments); }
    gtag('js', new Date());

    gtag('config', 'G-M95CKRP8HB');
</script>

<body>
    <nav class="nav-extended" style="background: black; margin-top: 0mm">
        <div class="nav-wrapper">
            <h1 id="main-heading">Visualize It</h1>
        </div>
        <div class="nav-content">
            <ul class="tabs tabs-transparent tabs-fixed-width">
                <li class="tab"><a class="active" href="#" style="font-size:larger;">Home</a></li>
                <li class="tab"><a href="about.html" style="font-size:larger;">About</a></li>
            </ul>
        </div>
    </nav>

    <br>

    <div class="text">
        <div class="container" style="width:90%">
            <center>
                <b class="flow-text">View scientific concepts at work. Anytime. Anywhere.</b>
                <br>
                <em>For comments, feedback and topic suggestions, please send a mail to <a
                        href="mailto:chanrt.visualize@gmail.com">chanrt.visualize@gmail.com</a> or tweet me <a
                        href="https://twitter.com/_chanrt_">@_chanrt_</a></em>

                <br> <br>
                <b>Filter by Subject:</b>
                <br>
                <div class="row">
                    <div class="col s12 l3">
                        <label>
                            <input id="physics-check" type="checkbox" class="filled-in" checked="checked"
                                onchange="toggle('physics')" />
                            <span class="filter-type">Physics</span>
                            <!--
                                12 pages:
                                Ising Model
                                Special Relativity
                                Spring Motion
                                Lorenz System
                                Nuclear Fusion
                                Double Pendulum
                                Quantum Computing
                                Simple Fluid
                                Projectile Motion
                                Stroboscopic Effect
                                Linear Momentum
                                Planetary Motion
                            -->
                        </label>
                    </div>
                    <div class="col s12 l3">
                        <label>
                            <input id="math-check" type="checkbox" class="filled-in" checked="checked"
                                onchange="toggle('math')" />
                            <span class="filter-type">Mathematics</span>
                            <!--
                                8 pages:
                                Trigonometric Functions
                                Mandelbrot Fractal
                                Bernoulli Percolation
                                Fourier Series
                                Hilbert Curve
                                Linear Transforms
                                Porous Percolation
                                Random Walks
                            -->
                        </label>
                    </div>
                    <div class="col s12 l3">
                        <label>
                            <input id="computer-check" type="checkbox" class="filled-in" checked="checked"
                                onchange="toggle('computer')" />
                            <span class="filter-type">Computer Science</span>
                            <!--
                                13 pages:
                                Ant Colony Optimization
                                Sorting Algorithms
                                Hopfield Networks
                                Gradient Descent
                                Image Filters
                                Polynomial Regression
                                Clustering
                                Genetic Algorithm
                                Maze Generation
                                Monte-Carlo
                                Bezier Curve
                                Lexical Analysis
                                Travelling Salesman
                            -->
                        </label>
                    </div>
                    <div class="col s12 l3">
                        <label>
                            <input id="complex-check" type="checkbox" class="filled-in" checked="checked"
                                onchange="toggle('complex')" />
                            <span class="filter-type">Complex Systems</span>
                            <!--
                                12 pages:
                                Firefly Synchronization
                                Game of Life
                                Schelling's Model
                                Lotka Volterra
                                Small-World Networks
                                Collective Behaviour
                                Public Goods
                                Reaction Diffusion
                                Pedestrian Dynamics
                                Contact Process
                                Directed Percolation
                                Vicsek Model
                            -->
                        </label>
                    </div>
                </div>
            </center>

            <hr>
            <br>

            <div class="row physics">
                <div class="col s12 l5">
                    <img class="responsive-img" src="images_webp/ising_model.webp" alt="ising model">
                </div>
                <div class="col s12 l7">
                    <h2 style="margin:0">Ising Model</h2>
                    <center>
                        <span>#physics #simulation</span>
                    </center>
                    <p class="flow-text">
                        Explore the Ising Model of Ferromagnetism. Tweak parameters like temperature and interaction
                        strength, and see how the system evolves in real-time! Learn how the simulation works.
                    </p>
                    <center>
                        <a href="ising_model/simulation.html">
                            <button class="btn purple darken-4 visit-button">Visit</button>
                        </a>
                    </center>
                </div>
                <br>
                <hr>
                <br>
            </div>


            <div class="row math">
                <div class="col s12 l5">
                    <img class="responsive-img" src="images_webp/trig_functions.webp" alt="trigonometric functions">
                </div>
                <div class="col s12 l7">
                    <h2 style="margin:0">Trigonometric Functions</h2>
                    <center>
                        <span>#mathematics #visualization</span>
                    </center>
                    <p class="flow-text">
                        Does trigonometry still bring in the sweats? Or do you want to intuitively understand it?
                        Whatever be the case, this interactive visualization provides a highly intuitive and visual
                        understanding of all six Trigonometric functions, their properties and identities.
                    </p>
                    <center>
                        <a href="trig_functions/simulation.html">
                            <button class="btn purple darken-4 visit-button">Visit</button>
                        </a>
                    </center>
                </div>
                <br>
                <hr>
                <br>
            </div>

            <div class="row computer">
                <div class="col s12 l5">
                    <img class="responsive-img" src="images_webp/ant_colony.webp" alt="ant colony optimization">
                </div>
                <div class="col s12 l7">
                    <h2 style="margin:0">Ant Colony</h2>
                    <center>
                        <span>#computer-science #simulation</span>
                    </center>
                    <p class="flow-text">
                        Ant Colony Optimization (ACO) is an interesting way to obtain near-optimum solutions to the
                        Travelling
                        Salesman Problem (TSP). This simulation allows you to change the optimization parameters in
                        real-time to notice their effects
                    </p>
                    <center>
                        <a href="ant_colony_optimization/simulation.html">
                            <button class="btn purple darken-4 visit-button">Visit</button>
                        </a>
                    </center>
                </div>
                <br>
                <hr>
                <br>
            </div>

            <div class="row complex">
                <div class="col s12 l5">
                    <img class="responsive-img" src="images_webp/firefly_sync.webp" alt="firefly synchronization">
                </div>
                <div class="col s12 l7">
                    <h2 style="margin:0">Firefly Sync</h2>
                    <center>
                        <span>#complex-systems #simulation</span>
                    </center>
                    <p class="flow-text">
                        Fireflies have an internal clock on the basis of which they emit light periodically. However,
                        they manage to sync up their cycles by observing their neighbours and nudging their phase
                        accordingly. See this mechanism in action!
                    </p>
                    <center>
                        <a href="firefly_synchronization/simulation.html">
                            <button class="btn purple darken-4 visit-button">Visit</button>
                        </a>
                    </center>
                </div>
                <br>
                <hr>
                <br>
            </div>

            <div class="row physics">
                <div class="col s12 l5">
                    <img class="responsive-img" src="images_webp/special_relativity.webp" alt="special relativity">
                </div>
                <div class="col s12 l7">
                    <h2 style="margin:0">Special Relativity</h2>
                    <center>
                        <span>#physics #visualization</span>
                    </center>
                    <p class="flow-text">
                        Find out what Einstein's 1905 brain-child is about. Make your vehicle move as fast as you want
                        (but within physical limits) and view Time dilation, Length contraction and Relativistic Doppler
                        Effect in action.
                    </p>
                    <center>
                        <a href="special_relativity/simulation.html">
                            <button class="btn purple darken-4 visit-button">Visit</button>
                        </a>
                    </center>
                </div>
                <br>
                <hr>
                <br>
            </div>

            <div class="row computer">
                <div class="col s12 l5">
                    <img class="responsive-img" src="images_webp/sorting_algos.webp" alt="sorting algorithms">
                </div>
                <div class="col s12 l7">
                    <h2 style="margin:0">Sorting Algorithms</h2>
                    <center>
                        <span>#computer-science #visualization</span>
                    </center>
                    <p class="flow-text">
                        View the working of 7 sorting algorithms, step by step, alongside some juicy info! This
                        simulation also shows you operational parameters like number of array accesses and comparisons.
                    </p>
                    <center>
                        <a href="sorting_algos/simulation.html">
                            <button class="btn purple darken-4 visit-button">Visit</button>
                        </a>
                    </center>
                </div>
                <br>
                <hr>
                <br>
            </div>

            <div class="row complex">
                <div class="col s12 l5">
                    <img class="responsive-img" src="images_webp/collective_behaviour.webp" alt="collective behaviour">
                </div>
                <div class="col s12 l7">
                    <h2 style="margin:0">Collective Behaviour</h2>
                    <center>
                        <span>#complex-systems #simulation</span>
                    </center>
                    <p class="flow-text">
                        Simple interactions like repulsion, orientation and attraction, can operate to different extents
                        adn give rise to a variety of collective behaviours. Learn about swarms, swirls and flocks!
                    </p>
                    <center>
                        <a href="collective_behaviour/simulation.html">
                            <button class="btn purple darken-4 visit-button">Visit</button>
                        </a>
                    </center>
                </div>
                <br>
                <hr>
                <br>
            </div>

            <div class="row complex">
                <div class="col s12 l5">
                    <img class="responsive-img" src="images_webp/conways_game.webp" alt="conway's game of life">
                </div>
                <div class="col s12 l7">
                    <h2 style="margin:0">Game of Life</h2>
                    <center>
                        <span>#automaton #simulation</span>
                    </center>
                    <p class="flow-text">
                        Can a simple set of rules give rise to complex behaviour? Conway's Game of Life is also based on
                        a simple set of rules, put forth by John Conway in 1960s. From simple patterns like Gliders, to
                        self replicating entities and Turing complete computers have been devised in Conway's universe.
                    </p>
                    <center>
                        <a href="conway_game/simulation.html">
                            <button class="btn purple darken-4 visit-button">Visit</button>
                        </a>
                    </center>
                </div>
                <br>
                <hr>
                <br>
            </div>

            <div class="row">
                <div class="col s12 l5">
                    <img class="responsive-img" src="images_webp/hopfield.webp" alt="hopfield">
                </div>
                <div class="col s12 l7">
                    <h2 style="margin:0">Hopfield Networks</h2>
                    <center>
                        <span>#computer-science #visualization</span>
                    </center>
                    <p class="flow-text">
                        Hopfield networks are simple constructs that are capable of learning and recalling patterns
                        dynamically. Learn about how these processes are implemented, alongside an actual Hopfield
                        network!
                    </p>
                    <center>
                        <a href="hopfield_networks/simulation.html">
                            <button class="btn purple darken-4 visit-button">Visit</button>
                        </a>
                    </center>
                </div>
                <br>
                <hr>
                <br>
            </div>

            <div class="row complex">
                <div class="col s12 l5">
                    <img class="responsive-img" src="images_webp/schelling_model.webp" alt="schelling's model">
                </div>
                <div class="col s12 l7">
                    <h2 style="margin:0">Schelling's Model</h2>
                    <center>
                        <span>#complex-systems #simulation</span>
                    </center>
                    <p class="flow-text">
                        Schelling's Model is a simple agent-based model that replicates the segregation that takes place
                        in populations with different backgrounds or opinions. This interactive simulation allows you to
                        vary different parameters!
                    </p>
                    <center>
                        <a href="schelling_model/simulation.html">
                            <button class="btn purple darken-4 visit-button">Visit</button>
                        </a>
                    </center>
                </div>
                <br>
                <hr>
                <br>
            </div>

            <div class="row computer">
                <div class="col s12 l5">
                    <img class="responsive-img" src="images_webp/gradient_descent.webp" alt="gradient descent">
                </div>
                <div class="col s12 l7">
                    <h2 style="margin:0">Gradient Descent</h2>
                    <center>
                        <span>#computer-science #machine-learning</span>
                    </center>
                    <p class="flow-text">
                        The Gradient Descent algorithm is the powerhouse of machine learning. Regression models as well
                        as neural networks use this algorithm to optimize their working according to the training
                        examples. Experience it first-hand!
                    </p>
                    <center>
                        <a href="gradient_descent/simulation.html">
                            <button class="btn purple darken-4 visit-button">Visit</button>
                        </a>
                    </center>
                </div>
                <br>
                <hr>
                <br>
            </div>

            <div class="row math">
                <div class="col s12 l5">
                    <img class="responsive-img" src="images_webp/mandelbrot_fractal.webp" alt="mandelbrot fractal">
                </div>
                <div class="col s12 l7">
                    <h2 style="margin:0">Mandelbrot Fractal</h2>
                    <center>
                        <span>#mathematics</span>
                    </center>
                    <p class="flow-text">
                        The Mandelbrot Fractal ought to erase any doubts about the beauty of Math. It is amazing how a
                        simple iteration (f(z) = z<sup>2</sup> + c) can give rise to such complex, intricate,
                        self-repeating patterns. Zoom in and explore the beautiful sights!
                    </p>
                    <center>
                        <a href="mandelbrot_fractal/simulation.html">
                            <button class="btn purple darken-4 visit-button">Visit</button>
                        </a>
                    </center>
                </div>
                <br>
                <hr>
                <br>
            </div>

            <div class="row complex">
                <div class="col s12 l5">
                    <img class="responsive-img" src="images_webp/lotka_volterra.webp" alt="Lotka Volterra">
                </div>
                <div class="col s12 l7">
                    <h2 style="margin:0">Lotka Volterra</h2>
                    <center>
                        <span>#complex-systems #simulation</span>
                    </center>
                    <p class="flow-text">
                        The Lotka Volterra Model is a simple predator-prey model that can be used to study the
                        interactions between two species. This simulation is a spatial version of the same model. Vary
                        the model parameters and see how the populations of the species change over time.
                    </p>
                    <center>
                        <a href="lotka_volterra/simulation.html">
                            <button class="btn purple darken-4 visit-button">Visit</button>
                        </a>
                    </center>
                </div>
                <br>
                <hr>
                <br>
            </div>

            <div class="row physics">
                <div class="col s12 l5">
                    <img class="responsive-img" src="images_webp/spring_motion.webp" alt="spring motion">
                </div>
                <div class="col s12 l7">
                    <h2 style="margin:0">Spring Motion</h2>
                    <center>
                        <span>#physics #simulation</span>
                    </center>
                    <p class="flow-text">
                        Springs: the simplest non-linear physical system whose working is intuituvely obvious. Vary all
                        parameters, from spring constant to dispersion! View damped oscillations in action!
                    </p>
                    <center>
                        <a href="spring_motion/simulation.html">
                            <button class="btn purple darken-4 visit-button">Visit</button>
                        </a>
                    </center>
                </div>
                <br>
                <hr>
                <br>
            </div>

            <div class="row math">
                <div class="col s12 l5">
                    <img class="responsive-img" src="images_webp/bernoulli_percolation.webp"
                        alt="bernoulli percolation">
                </div>
                <div class="col s12 l7">
                    <h2 style="margin:0">Bernoulli Percolation</h2>
                    <center>
                        <span>#mathematics #visualization</span>
                    </center>
                    <p class="flow-text">
                        Bernoulli percolation is the simplest model that features a phase transition. This interactive
                        simulation allows you to witness this phase transition in real time.
                    </p>
                    <center>
                        <a href="bernoulli_percolation/simulation.html">
                            <button class="btn purple darken-4 visit-button">Visit</button>
                        </a>
                    </center>
                </div>
                <br>
                <hr>
                <br>
            </div>

            <div class="row complex">
                <div class="col s12 l5">
                    <img class="responsive-img" src="images_webp/small_world_networks.webp" alt="small-world networks">
                </div>
                <div class="col s12 l7">
                    <h2 style="margin:0">Small-World Networks</h2>
                    <center>
                        <span>#complex-systems #visualization</span>
                    </center>
                    <p class="flow-text">
                        Small-world networks represent the middle-ground between regular lattices and random graphs.
                        They have many interesting properties, and a lot of real-world interactions resemble small-world
                        networks. Explore this topic in an interactive manner!
                    </p>
                    <center>
                        <a href="small_world_networks/simulation.html">
                            <button class="btn purple darken-4 visit-button">Visit</button>
                        </a>
                    </center>
                </div>
                <br>
                <hr>
                <br>
            </div>

            <div class="row math">
                <div class="col s12 l5">
                    <img class="responsive-img" src="images_webp/fourier.webp" alt="fourier series">
                </div>
                <div class="col s12 l7">
                    <h2 style="margin:0">Fourier Series</h2>
                    <center>
                        <span>#mathematics #visualization</span>
                    </center>
                    <p class="flow-text">
                        The concept of Fourier Transforms and Series are pervasive in the fields of science and
                        technology, yet its understanding is impeded due to its cryptic nature. This visualization
                        attempts to rectify that, by providing a framework to better understand this topic.
                    </p>
                    <center>
                        <a href="fourier_series/simulation.html">
                            <button class="btn purple darken-4 visit-button">Visit</button>
                        </a>
                    </center>
                </div>
                <br>
                <hr>
                <br>
            </div>

            <div class="row computer">
                <div class="col s12 l5">
                    <img class="responsive-img" src="images_webp/image_filters.webp" alt="image filters">
                </div>
                <div class="col s12 l7">
                    <h2 style="margin:0">Image Filters</h2>
                    <center>
                        <span>#computer-science</span>
                    </center>
                    <p class="flow-text">
                        Simple matrix operations on RGB values of an image can transform various aspects of the image or
                        yield useful information. this interactive visualization allows you to apply your own kernels to
                        a collection of images.
                    </p>
                    <center>
                        <a href="image_filters/simulation.html">
                            <button class="btn purple darken-4 visit-button">Visit</button>
                        </a>
                    </center>
                </div>
                <br>
                <hr>
                <br>
            </div>

            <div class="row physics">
                <div class="col s12 l5">
                    <img class="responsive-img" src="images_webp/lorenz_system.webp" alt="lorenz system">
                </div>
                <div class="col s12 l7">
                    <h2 style="margin:0">Lorenz System</h2>
                    <center>
                        <span>#mathematics #simulation</span>
                    </center>
                    <p class="flow-text">
                        Ever come across the term "Butterfly Effect" in the context of chaos? It is generated by the
                        Lorenz system of equations. Vary the parameters a little and see the trajectory change a lot!
                        Come across the set of equations that generate these patterns.
                    </p>
                    <center>
                        <a href="lorenz_system/simulation.html">
                            <button class="btn purple darken-4 visit-button">Visit</button>
                        </a>
                    </center>
                </div>
                <br>
                <hr>
                <br>
            </div>

            <div class="row physics">
                <div class="col s12 l5">
                    <img class="responsive-img" src="images_webp/nuclear_fusion.webp" alt="nuclear fusion">
                </div>
                <div class="col s12 l7">
                    <h2 style="margin:0">Nuclear Fusion</h2>
                    <center>
                        <span>#physics #simulation</span>
                    </center>
                    <p class="flow-text">
                        This simulation attempts to recreate the conditions under which Nuclear fusion takes place.
                        Efficient and sustainable nuclear fusion will be revolutionary to our energy sector and change
                        the future of our species!
                    </p>
                    <center>
                        <a href="nuclear_fusion/simulation.html">
                            <button class="btn purple darken-4 visit-button">Visit</button>
                        </a>
                    </center>
                </div>
                <br>
                <hr>
                <br>
            </div>

            <div class="row complex">
                <div class="col s12 l5">
                    <img class="responsive-img" src="images_webp/vicsek_model.webp" alt="Vicsek Model">
                </div>
                <div class="col s12 l7">
                    <h2 style="margin:0">Vicsek Model</h2>
                    <center>
                        <span>#complex-systems #simulation</span>
                    </center>
                    <p class="flow-text">
                        Vicsek model is a simple agent-based model that describes the behaviour of self-propelled
                        entities. This model is also known to show a phase transition from disordered has to ordered
                        fluid. Fiddle around with this interactive simulation.
                    </p>
                    <center>
                        <a href="vicsek_model/simulation.html">
                            <button class="btn purple darken-4 visit-button">Visit</button>
                        </a>
                    </center>
                </div>
                <br>
                <hr>
                <br>
            </div>

            <div class="row physics">
                <div class="col s12 l5">
                    <img class="responsive-img" src="images_webp/double_pendulum.webp" alt="double pendulum">
                </div>
                <div class="col s12 l7">
                    <h2 style="margin:0">Double Pendulum</h2>
                    <center>
                        <span>#physics #simulation</span>
                    </center>
                    <p class="flow-text">
                        Double pendulum is a simple system that exhibits deterministic chaos. This simulation showcases
                        why it is meaningless to predict long-term behaviour of chaotic systems.
                    </p>
                    <center>
                        <a href="double_pendulum/simulation.html">
                            <button class="btn purple darken-4 visit-button">Visit</button>
                        </a>
                    </center>
                </div>
                <br>
                <hr>
                <br>
            </div>

            <div class="row complex">
                <div class="col s12 l5">
                    <img class="responsive-img" src="images_webp/public_goods.webp" alt="public goods">
                </div>
                <div class="col s12 l7">
                    <h2 style="margin:0">Public Goods</h2>
                    <center>
                        <span></span>
                    </center>
                    <p class="flow-text">
                        A public good (eg: lighthouse) is any service that is non-excludable and non-exhaustible. Yet,
                        one requires resources for their establishment and maintenance. This simulation explores a
                        circumstance when public goods can be maintained even when free-riders are untraceable
                    </p>
                    <center>
                        <a href="public_goods/simulation.html">
                            <button class="btn purple darken-4 visit-button">Visit</button>
                        </a>
                    </center>
                </div>
                <br>
                <hr>
                <br>
            </div>

            <div class="row computer">
                <div class="col s12 l5">
                    <img class="responsive-img" src="images_webp/polynomial_regression.webp"
                        alt="polynomial regression">
                </div>
                <div class="col s12 l7">
                    <h2 style="margin:0">Polynomial Regression</h2>
                    <center>
                        <span>#computer-science #machine-learning</span>
                    </center>
                    <p class="flow-text">
                        Polynomial Regression is the process of fitting a bunch of points to a polynomial of a given
                        order. It forms the basis for several Machine Learning algorithms. This simulation allows you to
                        define your own points and find the best fit using the polynomial of the given degree.
                    </p>
                    <center>
                        <a href="polynomial_regression/simulation.html">
                            <button class="btn purple darken-4 visit-button">Visit</button>
                        </a>
                    </center>
                </div>
                <br>
                <hr>
                <br>
            </div>

            <div class="row complex">
                <div class="col s12 l5">
                    <img class="responsive-img" src="images_webp/reaction_diffusion.webp" alt="reaction diffusion">
                </div>
                <div class="col s12 l7">
                    <h2 style="margin:0">Reaction Diffusion</h2>
                    <center>
                        <span>#complex-systems #simulation</span>
                    </center>
                    <p class="flow-text">
                        A complex spatio-temporal model known to generate beautiful and intricate patterns! Reaction
                        Diffusion systems have various uses in chemistry, physics, biology and ecology. This simulation
                        allows you to draw on the canvas and watch both reaction and diffusion in action!
                    </p>
                    <center>
                        <a href="reaction_diffusion/simulation.html">
                            <button class="btn purple darken-4 visit-button">Visit</button>
                        </a>
                    </center>
                </div>
                <br>
                <hr>
                <br>
            </div>

            <div class="row math">
                <div class="col s12 l5">
                    <img class="responsive-img" src="images_webp/hilbert_curve.webp" alt="hilbert curve">
                </div>
                <div class="col s12 l7">
                    <h2 style="margin:0">Hilbert Curve</h2>
                    <center>
                        <span>#mathematics</span>
                    </center>
                    <p class="flow-text">
                        Is it possible to traverse through entire space with a line that doesn't cross itself? Hilbert
                        curve is a 2D space filling curve that does the job. Increase the order to see the curve
                        progressively fill up the entire space.
                    </p>
                    <center>
                        <a href="hilbert_curve/simulation.html">
                            <button class="btn purple darken-4 visit-button">Visit</button>
                        </a>
                    </center>
                </div>
                <br>
                <hr>
                <br>
            </div>

            <div class="row complex">
                <div class="col s12 l5">
                    <img class="responsive-img" src="images_webp/pedestrian_dynamics.webp" alt="pedestrian dynamics">
                </div>
                <div class="col s12 l7">
                    <h2 style="margin:0">Pedestrian Dynamics</h2>
                    <center>
                        <span>#complex-systems #simulation</span>
                    </center>
                    <p class="flow-text">
                        This simulation showcases how lane formation as well as phantom traffic james happen in a crowd
                        of pedestrians who merely want to avoid crashing into each other. Explore how bias in direction
                        and variance in speed affects the flow of the crowd.
                    </p>
                    <center>
                        <a href="pedestrian_dynamics/simulation.html">
                            <button class="btn purple darken-4 visit-button">Visit</button>
                        </a>
                    </center>
                </div>
                <br>
                <hr>
                <br>
            </div>

            <div class="row physics">
                <div class="col s12 l5">
                    <img class="responsive-img" src="images_webp/quantum_computing.webp" alt="quantum computing">
                </div>
                <div class="col s12 l7">
                    <h2 style="margin:0">Quantum Computing</h2>
                    <center>
                        <span>#physics #simulation</span>
                    </center>
                    <p class="flow-text">
                        Quantum Computers are expected to beat classical computers at solving certain classes of
                        problems. They can easily simulate quantum systems too. In this simulation, play with the
                        building blocks of Quantum Circuits!
                    </p>
                    <center>
                        <a href="quantum_logic/simulation.html">
                            <button class="btn purple darken-4 visit-button">Visit</button>
                        </a>
                    </center>
                </div>
                <br>
                <hr>
                <br>
            </div>

            <div class="row computer">
                <div class="col s12 l5">
                    <img class="responsive-img" src="images_webp/clustering.webp" alt="k-means clustering">
                </div>
                <div class="col s12 l7">
                    <h2 style="margin:0">Clustering</h2>
                    <center>
                        <span>#computer-science #machine-learning</span>
                    </center>
                    <p class="flow-text">
                        Explore the working of k-means clustering algorithm, with a hands-on simulation. This algorithm
                        is widely used in unsupervised machine learning.
                    </p>
                    <center>
                        <a href="clustering/simulation.html">
                            <button class="btn purple darken-4 visit-button">Visit</button>
                        </a>
                    </center>
                </div>
                <br>
                <hr>
                <br>
            </div>

            <div class="row complex">
                <div class="col s12 l5">
                    <img class="responsive-img" src="images_webp/contact_process.webp" alt="contact process">
                </div>
                <div class="col s12 l7">
                    <h2 style="margin:0">Contact Process</h2>
                    <center>
                        <span>#automaton #simulation</span>
                    </center>
                    <p class="flow-text">
                        A randomized cellular automaton that is widely used in percolation theory and extinction theory,
                        to approximate mean-field models in various fields of science.
                    </p>
                    <center>
                        <a href="contact_process/simulation.html">
                            <button class="btn purple darken-4 visit-button">Visit</button>
                        </a>
                    </center>
                </div>
                <br>
                <hr>
                <br>
            </div>

            <div class="row computer">
                <div class="col s12 l5">
                    <img class="responsive-img" src="images_webp/genetic_algo.webp" alt="genetic algorithm">
                </div>
                <div class="col s12 l7">
                    <h2 style="margin:0">Genetic Algorithm</h2>
                    <center>
                        <span>#computer-science #simulation</span>
                    </center>
                    <p class="flow-text">
                        View the process behind the diversity of lifeforms we see today! This simulation utilizes an
                        Evolutionary Algorithm to select the boid with the best genes. Change the positions of the
                        source, target and the obstacles to build your own custom worlds!
                    </p>
                    <center>
                        <a href="natural_selection/simulation.html">
                            <button class="btn purple darken-4 visit-button">Visit</button>
                        </a>
                    </center>
                </div>
                <br>
                <hr>
                <br>
            </div>

            <div class="row physics">
                <div class="col s12 l5">
                    <img class="responsive-img" src="images_webp/simple_fluid.webp" alt="simple fluid">
                </div>
                <div class="col s12 l7">
                    <h2 style="margin:0">Simple Fluid</h2>
                    <center>
                        <span>#physics #visualization</span>
                    </center>
                    <p class="flow-text">
                        This is an attempt to simulate fluids for educational and aesthetic purposes. Obtain a
                        simplified understanding of the Navier-Stokes equation!
                    </p>
                    <center>
                        <a href="simple_fluid/simulation.html">
                            <button class="btn purple darken-4 visit-button">Visit</button>
                        </a>
                    </center>
                </div>
                <br>
                <hr>
                <br>
            </div>

            <div class="row math">
                <div class="col s12 l5">
                    <img class="responsive-img" src="images_webp/linear_transformations.webp"
                        alt="linear transformations">
                </div>
                <div class="col s12 l7">
                    <h2 style="margin:0">Linear Transforms</h2>
                    <center>
                        <span>#mathematics</span>
                    </center>
                    <p class="flow-text">
                        Play around with the operation that is central to linear algebra. The coordinate system is your
                        playground. Scale, rotate and skew! Encounter rotation matrices and inverses. See what a matrix
                        with zero determinant does to the linear space.
                    </p>
                    <center>
                        <a href="linear_transformations/simulation.html">
                            <button class="btn purple darken-4 visit-button">Visit</button>
                        </a>
                    </center>
                </div>
                <br>
                <hr>
                <br>
            </div>

            <div class="row physics">
                <div class="col s12 l5">
                    <img class="responsive-img" src="images_webp/projectile_motion.webp" alt="projectile motion">
                </div>
                <div class="col s12 l7">
                    <h2 style="margin:0">Projectile Motion</h2>
                    <center>
                        <span>#physics #simulation #game</span>
                    </center>
                    <p class="flow-text">
                        An everyday example of 2D motion. Explore projectile motion through the lens of a game. Try to
                        hit the blue target with the correct initial velocity and angle!
                    </p>
                    <center>
                        <a href="projectile_motion/simulation.html">
                            <button class="btn purple darken-4 visit-button">Visit</button>
                        </a>
                    </center>
                </div>
                <br>
                <hr>
                <br>
            </div>

            <div class="row computer">
                <div class="col s12 l5">
                    <img class="responsive-img" src="images_webp/maze_generation.webp" alt="maze generation">
                </div>
                <div class="col s12 l7">
                    <h2 style="margin:0">Maze Generation</h2>
                    <center>
                        <span>#computer-science #visualization</span>
                    </center>
                    <p class="flow-text">
                        Ever wondered how maze generation algorithms work? This simulation encompasses three maze
                        generation algorithms (as of now). Also found brief description of the step-by-step working of
                        these algorithm, along with their pros and cons.
                    </p>
                    <center>
                        <a href="maze_generation/simulation.html">
                            <button class="btn purple darken-4 visit-button">Visit</button>
                        </a>
                    </center>
                </div>
                <br>
                <hr>
                <br>
            </div>

            <div class="row physics">
                <div class="col s12 l5">
                    <img class="responsive-img" src="images_webp/stroboscopic_effect.webp" alt="stroboscopic effect">
                </div>
                <div class="col s12 l7">
                    <h2 style="margin:0">Stroboscopic Effect</h2>
                    <center>
                        <span>#illusion</span>
                    </center>
                    <p class="flow-text">
                        Haven't you observed weird stuff happening with rotating objects? A reversal of direction?
                        Spokes rotating slower than they ought to? Or a flying helicopter with stationary rotors? This
                        simulation explains and showcases this illusion.
                    </p>
                    <center>
                        <a href="stroboscopic_effect/simulation.html">
                            <button class="btn purple darken-4 visit-button">Visit</button>
                        </a>
                    </center>
                </div>
                <br>
                <hr>
                <br>
            </div>

            <div class="row computer">
                <div class="col s12 l5">
                    <img class="responsive-img" src="images_webp/monte_carlo.webp" alt="monte carlo simulation">
                </div>
                <div class="col s12 l7">
                    <h2 style="margin:0">Monte Carlo</h2>
                    <center>
                        <span>#simulation</span>
                    </center>
                    <p class="flow-text">
                        Gain the intution behind Monte Carlo simulations by using it to quickly estimate the value of pi
                        using nothing except random numbers! Monte Carlo simulations allow us to obtain numerical
                        results from randomness.
                    </p>
                    <center>
                        <a href="monte_carlo/simulation.html">
                            <button class="btn purple darken-4 visit-button">Visit</button>
                        </a>
                    </center>
                </div>
                <br>
                <hr>
                <br>
            </div>

            <div class="row physics">
                <div class="col s12 l5">
                    <img class="responsive-img" src="images_webp/linear_momentum.webp" alt="linear momentum">
                </div>
                <div class="col s12 l7">
                    <h2 style="margin:0">Linear Momentum</h2>
                    <center>
                        <span>#physics #game</span>
                    </center>
                    <p class="flow-text">
                        The conservation of linear momentum is a central topic in all avenues of Physics. Observe the
                        computer AI crush you repeatedly at Pong by using this concept!
                    </p>
                    <center>
                        <a href="linear_momentum/simulation.html">
                            <button class="btn purple darken-4 visit-button">Visit</button>
                        </a>
                    </center>
                </div>
                <br>
                <hr>
                <br>
            </div>

            <div class="row math">
                <div class="col s12 l5">
                    <img class="responsive-img" src="images_webp/porous_percolation.webp" alt="porous percolation">
                </div>
                <div class="col s12 l7">
                    <h2 style="margin:0">Porous Percolation</h2>
                    <center>
                        <span>#mathematics #visualization</span>
                    </center>
                    <p class="flow-text">
                        This simulation visualizes the percolation of fluid through a porous medium. Change the porosity
                        of the medium, and witness a sharp transition that takes place at 0.59!
                    </p>
                    <center>
                        <a href="porous_percolation/simulation.html">
                            <button class="btn purple darken-4 visit-button">Visit</button>
                        </a>
                    </center>
                </div>
                <br>
                <hr>
                <br>
            </div>

            <div class="row computer">
                <div class="col s12 l5">
                    <img class="responsive-img" src="images_webp/bezier_curves.webp" alt="bezier curves">
                </div>
                <div class="col s12 l7">
                    <h2 style="margin:0">Bezier Curve</h2>
                    <center>
                        <span>#computer-science</span>
                    </center>
                    <p class="flow-text">
                        Computers use Bezier curve to render all text based elements. Further, they are widely used in
                        designing and computer graphics. Design your own curves using this simulation! Use as many
                        control points as you wish!
                    </p>
                    <center>
                        <a href="bezier_curves/simulation.html">
                            <button class="btn purple darken-4 visit-button">Visit</button>
                        </a>
                    </center>
                </div>
                <br>
                <hr>
                <br>
            </div>

            <div class="row math">
                <div class="col s12 l5">
                    <img class="responsive-img" src="images_webp/random_walks.webp" alt="random walks">
                </div>
                <div class="col s12 l7">
                    <h2 style="margin:0">Random Walks</h2>
                    <center>
                        <span>#simulation</span>
                    </center>
                    <p class="flow-text">
                        Explore the subtle relationship between unbiased random walks, binomial distribution, central
                        limit theorem, Pascal's triangle and normal distribution. Simulate thousands of animals walking
                        any distance you want and analyse their distribution!
                    </p>
                    <center>
                        <a href="random_walk/simulation.html">
                            <button class="btn purple darken-4 visit-button">Visit</button>
                        </a>
                    </center>
                </div>
                <br>
                <hr>
                <br>
            </div>

            <div class="row physics">
                <div class="col s12 l5">
                    <img class="responsive-img" src="images_webp/planetary_motion.webp" alt="planetary motion">
                </div>
                <div class="col s12 l7">
                    <h2 style="margin:0">Planetary Motion</h2>
                    <center>
                        <span>#physics #simulation</span>
                    </center>
                    <p class="flow-text">
                        The Law of Universal Gravitation is aptly named. Put forth by Isaac Newton in 1687, it describes
                        the motion of every massive particle in the universe. Play around this framework with as many
                        bodies as you like!
                    </p>
                    <center>
                        <a href="planetary_motion/simulation.html">
                            <button class="btn purple darken-4 visit-button">Visit</button>
                        </a>
                    </center>
                </div>
                <br>
                <hr>
                <br>
            </div>

            <div class="row complex">
                <div class="col s12 l5">
                    <img class="responsive-img" src="images_webp/tdp.webp" alt="directed percolation">
                </div>
                <div class="col s12 l7">
                    <h2 style="margin:0">Directed Percolation</h2>
                    <center>
                        <span>#complex-systems #automaton</span>
                    </center>
                    <p class="flow-text">
                        Tricritical Directed Percolation (TDP) is a simple probabilistic model that can be used to study
                        vegetation dynamics. This model features continuous and abrupt transitions. Witness them in
                        real-time.
                    </p>
                    <center>
                        <a href="tdp/simulation.html">
                            <button class="btn purple darken-4">Visit</button>
                        </a>
                    </center>
                </div>
                <br>
                <hr>
                <br>
            </div>

            <div class="row computer">
                <div class="col s12 l5">
                    <img class="responsive-img" src="images_webp/lexical_analysis.webp" alt="lexical analysis">
                </div>
                <div class="col s12 l7">
                    <h2 style="margin:0">Lexical Analysis</h2>
                    <center>
                        <span>#computer-science</span>
                    </center>
                    <p class="flow-text">
                        Lexical Analysers convert user-written programs into tokens, before being passed on to the
                        compiler. Explore the working of a simple lexical analyser!
                    </p>
                    <center>
                        <a href="lexical_analysis/simulation.html">
                            <button class="btn purple darken-4 visit-button">Visit</button>
                        </a>
                    </center>
                </div>
                <br>
                <hr>
                <br>
            </div>

            <div class="row computer">
                <div class="col s12 l5">
                    <img class="responsive-img" src="images_webp/travelling_salesman.webp" alt="travelling salesman">
                </div>
                <div class="col s12 l7">
                    <h2 style="margin:0">Travelling Salesman</h2>
                    <center>
                        <span>#computer-science</span>
                    </center>
                    <p class="flow-text">
                        A salesman wants to cover all places of interest through the shortest path possible and without
                        visiting the same place twice. What path should he follow? This deceptively simple looking
                        problem becomes extremely diffucult to solve as the number of places increases!
                    </p>
                    <center>
                        <a href="travelling_salesman/simulation.html">
                            <button class="btn purple darken-4 visit-button">Visit</button>
                        </a>
                    </center>
                </div>
                <br>
                <hr>
                <br>
            </div>

            <!-- template -->
            <!-- <div class="row">
                <div class="col s12 l5">
                    <img class="responsive-img" src="images_webp/" alt="image">
                </div>
                <div class="col s12 l7">
                    <h2 style="margin:0"></h2>
                    <center>
                        <span></span>
                    </center>
                    <p class="flow-text">

                    </p>
                    <center>
                        <a href="/simulation.html">
                            <button class="btn purple darken-4 visit-button">Visit</button>
                        </a>
                    </center>
                </div>
                <br>
                <hr>
                <br>
            </div> -->

            <a rel="me" href="https://ecoevo.social/@chandan" style="display:none">Mastodon</a>

            <center>
                <p>Developed by Chandan Relekar | Fork me at <a href="https://www.github.com/chanrt">GitHub</a></p>
            </center>
        </div>
    </div>

</body>

</html>


================================================
FILE: index.js
================================================
let physics, computer, math, complex;

let physicsContent, computerContent, mathContent, complexContent;

function toggle(topic) {
    if (topic == "physics") {
        physics = !physics
    }
    if (topic == "computer") {
        computer = !computer
    }
    if (topic == "math") {
        math = !math
    }
    if (topic == "complex") {
        complex = !complex
    }

    changeContents();
}

function changeContents() {
    if (physics) {
        for (let i = 0; i < physicsContent.length; i++) {
            physicsContent[i].style.display = "block";
        }
    } else {
        for (let i = 0; i < physicsContent.length; i++) {
            physicsContent[i].style.display = "none";
        }
    } 

    if (computer) {
        for (let i = 0; i < computerContent.length; i++) {
            computerContent[i].style.display = "block";
        }
    }
    else {
        for (let i = 0; i < computerContent.length; i++) {
            computerContent[i].style.display = "none";
        }
    }

    if (math) {
        for (let i = 0; i < mathContent.length; i++) {
            mathContent[i].style.display = "block";
        }
    }
    else {
        for (let i = 0; i < mathContent.length; i++) {
            mathContent[i].style.display = "none";
        }
    }

    if (complex) {
        for (let i = 0; i < complexContent.length; i++) {
            complexContent[i].style.display = "block";
        }
    }
    else {
        for (let i = 0; i < complexContent.length; i++) {
            complexContent[i].style.display = "none";
        }
    }
}

window.onload = function () {
    physics = document.getElementById("physics-check").checked;
    computer = document.getElementById("computer-check").checked;
    math = document.getElementById("math-check").checked;
    complex = document.getElementById("complex-check").checked;

    physicsContent = document.getElementsByClassName("physics");
    computerContent = document.getElementsByClassName("computer");
    mathContent = document.getElementsByClassName("math");
    complexContent = document.getElementsByClassName("complex");

    changeContents();
}


================================================
FILE: style.css
================================================
body {
  background-image: url(../background_patterns/webb-dark.png);
  background-color: #06040ae1;
  color: white;
  font-family: montserrat;
  max-width: 100%;
  overflow-x: hidden;
}

@font-face {
  font-family: roboto;
  src: url(../fonts/Roboto-Regular.ttf);
}

@font-face {
  font-family: sofia-sans;
  src: url(../fonts/SofiaSans-Medium.ttf);
}

@font-face {
  font-family: montserrat;
  src: url(../fonts/Montserrat-Regular.ttf);
}

@font-face {
  font-family: merriweather;
  src: url(../fonts/Merriweather-Regular.ttf);
}

p {
  color: white;
}

input {
    color: white;
    width: 50%;
    text-align: center;
}

b {
  color: white;
}

a {
  color: rgba(143, 173, 255, 0.979);
}

button:hover {
  opacity: 80%;
}

h1, h2, h3, h4, h5 {
  color: white;
  text-align: center;
}

h3 {
  margin-top: 50px;
}

.text {
  margin: 1%;
  font-size: large;
}

ul li::before {
  color: white;
}

li {
  list-style-type: circle;
  color: white;
}

nav div ul li {
  font-size: large;
}

#main-heading {
  margin-top: 0mm;
  padding: 5mm;
  text-align: center;
}

.jittery {
  font-family: monospace;
  font-size: larger;
}

.filter-type {
  color: white;
  font-size: larger;
  font-weight: bold;
}

.visit-button {
  margin-bottom: 20px;
}

.slidecontainer {
  width: 100%;
}

.slider {
  -webkit-appearance: none; /* Override default CSS styles */
  appearance: none;
  width: 100%; /* Full-width */
  height: 25px; /* Specified height */
  background: #d3d3d3; /* Grey background */
  outline: none; /* Remove outline */
  opacity: 0.7; /* Set transparency (for mouse-over effects on hover) */
  -webkit-transition: 0.2s; /* 0.2 seconds transition on hover */
  transition: opacity 0.2s;
}

hr {
  margin: 10px;
  padding: 0px;
  display:block;
  clear: both;
  width: 100%;               
  background-color:#ffffff;
  height: 1px;
}

.loader {
  position: absolute;
  top: calc(50% - 60px);
  left: calc(50% - 60px);
  border: 16px solid #f3f3f3; /* Light grey */
  border-top: 16px solid #3498db; /* Blue */
  border-radius: 50%;
  width: 120px;
  height: 120px;
  animation: spin 2s linear infinite;
}

@keyframes spin {
  0% {
      transform: rotate(0deg);
  }
  100% {
      transform: rotate(360deg);
  }
}



================================================
FILE: ant_colony_optimization/basic.js
================================================
let screen_width = window.innerWidth, screen_height = window.innerHeight;
let canvas_width, canvas_height;
let fps = 24, paused = false;
let mobile;

if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
    mobile = true;
} else {
    mobile = false;
}

let canvas = document.getElementById("canvas");
let context = canvas.getContext("2d");

if (mobile) {
    canvas_width = 0.9 * screen_width;
}
else {
    canvas_width = 0.4 * screen_width;
}
canvas_height = canvas_width;

canvas.width = canvas_width;
canvas.height = canvas_height;

num_input = document.getElementById("num-input");
num_display = document.getElementById("num-display");

eva_input = document.getElementById("eva-input");
eva_display = document.getElementById("eva-display");

phe_input = document.getElementById("phe-input");
phe_display = document.getElementById("phe-display");

apr_input = document.getElementById("apr-input");
apr_display = document.getElementById("apr-display");

let animate = window.requestAnimationFrame
    || window.webkitRequestAnimationFrame
    || window.mozRequestAnimationFrame
    || function (callback) {
        window.setTimeout(callback, 1000 / fps);
    };

function step() {
    if (!paused) {
        update();
    }
    render();
    animate(step);
}

window.onload = function () {
    defaultParams();
    initParams();
    animate(step);
}

function defaultParams() {
    num_input.value = 10;
    eva_input.value = 0.1;
    phe_input.value = 1;
    apr_input.value = 0.5;
}

let click_x, click_y, pressed;

if(mobile) {
    canvas.addEventListener("touchstart", function (e) {
        getTouchPosition(canvas, e);
        let touch = e.touches[0];
        let mouseEvent = new MouseEvent("mousedown", {
            clientX: touch.clientX,
            clientY: touch.clientY
        });
        canvas.dispatchEvent(mouseEvent);
        pressed = true;
        clicked();
    }, false);

    canvas.addEventListener("touchmove", function (e) {
        getTouchPosition(canvas, e);
        let touch = e.touches[0];
        let mouseEvent = new MouseEvent("mousemove", {
            clientX: touch.clientX,
            clientY: touch.clientY
        });
        canvas.dispatchEvent(mouseEvent);
        moved();
    }, false);

    canvas.addEventListener("touchend", function (e) {
        getTouchPosition(canvas, e);
        let touch = e.touches[0];
        let mouseEvent = new MouseEvent("mouseup", {
            clientX: touch.clientX,
            clientY: touch.clientY
        });
        canvas.dispatchEvent(mouseEvent);
        pressed = false;
        released();
    }, false);
}
else {
    canvas.addEventListener("mousedown", function (e) {
        getMousePosition(canvas, e);
        pressed = true;
        clicked();
    });

    canvas.addEventListener("mousemove", function (e) {
        getMousePosition(canvas, e);
        moved();
    });

    canvas.addEventListener("mouseup", function (e) {
        getMousePosition(canvas, e);
        pressed = false;
        released();
    });

    window.addEventListener("keydown", function(e) {
        keyPressed(e.keyCode);
    }, false);

    window.addEventListener("keydown", function(e) {
        keyReleased(e.keyCode);
    }, false);
}

function getMousePosition(canvas, event) {
    rect = canvas.getBoundingClientRect();
    click_x = event.clientX - rect.left;
    click_y = event.clientY - rect.top;
}

function getTouchPosition(canvas, event) {
    var rect = canvas.getBoundingClientRect();
    click_x = event.touches[0].clientX - rect.left;
    click_y = event.touches[0].clientY - rect.top;
}


================================================
FILE: ant_colony_optimization/render.js
================================================
function render() {
    context.fillStyle = "#000000";
    context.fillRect(0, 0, canvas_width, canvas_height);

    renderPoints();
    if (running) {
        renderTrails();

        // draw progress bar on top
        context.fillStyle = "#ffffff";
        context.fillRect(0, 0, canvas_width * iteration / num_iterations, 3);
    }

    if (!running && optimum_solution !== undefined && optimum_solution.length != 0) {
        console.log("Hello");
        renderMinPath();
    }
}

function renderPoints() {
    for (let point of points) {
        context.beginPath();
        context.arc(point.x, point.y, near_cutoff, 0, 2 * Math.PI, false);
        context.fillStyle = "#ffffff";
        context.fill();
    }
}

function renderTrails() {
    let total_strength, relative_strength;
    for (let i = 0; i < pheromone_matrix.length; i++) {
        total_strength = 0;
        for (let j = 0; j < pheromone_matrix[i].length; j++) {
            if (i != j) {
                total_strength += Math.pow(pheromone_matrix[i][j], pheromone_influence) * Math.pow(apriori_matrix[i][j], apriori_influence);
            }
        }

        for (let j = 0; j < pheromone_matrix[i].length; j++) {
            if (i != j) {
                relative_strength = Math.pow(pheromone_matrix[i][j], pheromone_influence) * Math.pow(apriori_matrix[i][j], apriori_influence) ** 0.8;
                context.lineWidth = 1;
                context.strokeStyle = "rgba(255, 255, 255, " + relative_strength + ")";
                context.beginPath();
                context.moveTo(points[i].x, points[i].y);
                context.lineTo(points[j].x, points[j].y);
                context.stroke();
            }
        }
    }
}

function renderMinPath() {
    context.lineWidth = 2;
    context.strokeStyle = "#0000ff";
    context.beginPath();
    context.moveTo(points[optimum_solution[0]].x, points[optimum_solution[0]].y);
    for (let i = 1; i < optimum_solution.length; i++) {
        context.lineTo(points[optimum_solution[i]].x, points[optimum_solution[i]].y);
    }
    context.lineTo(points[optimum_solution[0]].x, points[optimum_solution[0]].y);
    context.stroke();
}


================================================
FILE: ant_colony_optimization/simulation.html
================================================
<!DOCTYPE html>
<html lang="en-US">

<head>
  <title>Ant Colony Optimization | Visualize It</title>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="keywords" content="Ant Colony Optimization, ACO, Travelling Salesman Problem, TSP, Simulation">
  <meta name="og:image"
    content="https://github.com/visualize-it/visualize-it.github.io/raw/main/images_webp/ant_colony.webp">

  <!-- Materialize -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/js/materialize.min.js"></script>

  <script src="../helper.js" defer></script>
  <script src="basic.js" defer></script>
  <script src="user_input.js" defer></script>
  <script src="simulation.js" defer></script>
  <script src="render.js" defer></script>

  <script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML">
    </script>

  <!-- CSS -->
  <link rel="stylesheet" href="../style.css" />
</head>

<script async src="https://www.googletagmanager.com/gtag/js?id=G-M95CKRP8HB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() { window.dataLayer.push(arguments); }
  gtag('js', new Date());

  gtag('config', 'G-M95CKRP8HB');
</script>

<body>
  <nav class="nav-extended" style="background:black; margin-top: 0mm">
    <div class="nav-wrapper">
      <h1 id="main-heading">Visualize It</h1>
    </div>
    <div class="nav-content">
      <ul class="tabs tabs-transparent tabs-fixed-width">
        <li class="tab"><a href="../index.html" style="font-size: larger;">Home</a></li>
        <li class="tab"><a href="../about.html" style="font-size: larger;">About</a></li>
      </ul>
    </div>
  </nav>

  <div class="text">
    <h2>Ant Colony</h2>
    <center>
      <p>Ant Colony Optimization (ACO) is an interesting way to obtain near-optimum solutions to the <a
          href="../travelling_salesman/simulation.html">Travelling Salesman
          Problem (TSP)</a>. It involves utilizing multi-agent ants to explore all possible solutions and converge upon
        a short path with a combination of a priori knowledge and pheromone trails deposited by other ants</p>
    </center>
    <br>

    <div class="container" style="width:90%">
      <div class="row">
        <div class="col s12 l8">
          <canvas id="canvas"></canvas>
        </div>
        <div class="col s12 l4">
          <center>
            <b>Click on the canvas in order to introduce/remove a node</b>
            <br> <br>
            <button class="btn purple darken-4" onclick="randomPoint()">Random point</button>
            <button class="btn purple darken-4" onclick="clearPoints()">Clear points</button>
            <hr>
            <button class="btn purple darken-4" onclick="initSimulation()">Start simulation</button> <br> <br>
            <b>Optimization Parameters:</b>
            <br>
            <span id="num-display"></span>
            <input id="num-input" type="range" min="1" max="100" step="1" oninput="updateParams('num')"
              onchange="updateParams('num')">
            <span id="eva-display"></span>
            <input id="eva-input" type="range" min="0" max="0.9" step="0.01" oninput="updateParams('eva')"
              onchange="updateParams('eva')">
            <span id="phe-display"></span>
            <input id="phe-input" type="range" min="0" max="2" step="0.1" oninput="updateParams('phe')"
              onchange="updateParams('phe')">
            <span id="apr-display"></span>
            <input id="apr-input" type="range" min="0" max="1" step="0.1" oninput="updateParams('apr')"
              onchange="updateParams('apr')">
          </center>
        </div>
      </div>
    </div>

    <br>
    <hr>

    <h3>Mechanism</h3>
    <p>
      Given a bunch of points, the travelling salesman problem involves finding the shortest path that visits all the
      points exactly once. Finding/verifying a solution absolutely requires a brute force search, whose time complexity
      scales as factorial. Ant Colony Optimization (ACO) is one way to go about finding near-optimal solutions for the
      travelling salesman problem.
    </p>
    <p>
      ACO involves keeping two matrices: the pheromone matrix \(P\) such that \(P_{ij}\) represents the amount of
      pheromone between nodes \(i\) and \(j\), and the <em>a priori</em> knowledge matrix \(A\) such that \(A_{ij}\)
      represents the <em>a priori</em> knowledge of the distance between nodes \(i\) and \(j\). In this case, we set
      \(A_{ij} = 1/d_{ij}\) where \(d_{ij}\) is the distance between nodes \(i\) and \(j\). The pheromone matrix is
      initialized to 1 in the beginning.
    </p>
    <p>
      When the \(n^{th}\) ant is at the \(i^{th}\) node, it can travel to any node which it hasn't visited yet. The
      probability that it will travel to the \(j^{th}\) node is given by
      \[
      p_{ij}^{(n)} = \frac{P_{ij}^\alpha A_{ij}^\beta}{\sum_{k \in U_a} P_{ik}^\alpha A_{ik}^\beta}
      \]
    </p>
    <p>
      Here, \(U_a\) is the set of nodes that the \(n^{th}\) ant has not visited yet, \(\alpha\) is the influence of the
      pheromones in the decision making process, and \(\beta\) is the influence of the <em>a priori</em> knowledge in
      the decision making process. During the simulation, the intensity of the line joining two edges is proportional to
      above probability
    </p>
    <p>
      When a population of ants have visited all nodes exactly once, the pheromone matrices are updated as
      follows:
      \[
      P_{ij} = (1 - \rho) P_{ij} + \sum_{n=1}^N \Delta P_{ij}^{(n)}
      \]
      \[
      P_{ij}^{(n)} =
      \begin{cases}
      Q / L_k & \text{if the \(n^{th}\) ant travelled from \(i\) to \(j\) while moving}\\
      0 & \text{otherwise}
      \end{cases}
      \]
    </p>
    <p>
      Here, \(\rho\) is the evaporation rate, or the fraction of the pheromone trail that would have evaporated by the
      next iteration. \(Q\) is a constant that determines the amount of pheromone deposited by each ant, and \(L_k\) is
      the length of the path taken by the \(k^{th}\) ant. After 200 iterations, the simulation will stop, and the path
      taken by the shortest any will be displayed.
    </p>

    <hr>

    <h3>Tweaking</h3>
    <ol>
      <li>
        A lower population of ants will cause the approximated optimal solution to change rapidly between iterations.
      </li>
      <li>
        A high value of evaporation rate allows the population to explore more paths, but it may not necessarily
        return an optimal path at the end</li>
      <li>
        \( (\alpha, \beta) = (0, 1) \) is equivalent to using only the <em>a priori</em> knowledge. The solution given
        will be the nearest neighbor heuristic, which is the most straightforward way to optimize the travelling
        salesman problem. Basically, from each node, travel to the nearest unvisited node.
      </li>
      <li>
        \( \alpha = 0 \) and \( \beta > 1 \) makes the system collapse to a local minimum. But the solution will
        probably be far from optimum.
      </li>
      <li>
        \( \alpha > 0.5 \) will lock the ants into heavily favouring shorter edges. The simulation will then try to find
        the a way to connected these shorter edges in an optimal manner.
      </li>
      <li>
        When points are chosen randomly, \( (\alpha, \beta) = (1, 1) \) seem to give the best results.
      </li>
    </ol>

    <br>
    <hr>

    <ol>
      <li>This simulation is computationally complex and will lag on lower-end devices</li>
      <li>You can change the evaporation factor, pheromone influence and <em>a priori</em> influence during the
        simulation to see how it affects the solution space.</li>
      <li>On the other hand, changing the number of ants during the simulation will cause it to restart</li>
      <li>Related: <a href="../travelling_salesman/simulation.html">Solving TSP by brute force</a></li>
    </ol>

    <br>
    <hr>

    <p class="center-align">Developed by ChanRT | Fork me at <a href="https://www.github.com/chanrt">GitHub</a></p>
  </div>
</body>

</html>


================================================
FILE: ant_colony_optimization/simulation.js
================================================
let points = [];
let near_cutoff;

let num_ants;
let pheromone_matrix, apriori_matrix;
let ant_paths;

let eva_factor, pheromone_influence, apriori_influence, rate;

let running, iteration;
let num_iterations;

let optimum_solution;

function update() {
    if (running) {
        // put ants in initial position
        placeAnts();

        // make them move one by one
        for (let ant = 0; ant < num_ants; ant++) {
            let current_node, possible_nodes;
            let probability, probabilities, normalization;
            let choose_random, cum_prob;

            // make ant move until it has visited all nodes
            while (ant_paths[ant].length < points.length) {
                current_node = ant_paths[ant][ant_paths[ant].length - 1];
                possible_nodes = [];

                // consider only those nodes which it hasn't visited
                for (let node = 0; node < points.length; node++) {
                    if (!pathContainsNode(ant_paths[ant], node)) {
                        possible_nodes.push(node);
                    }
                }

                // calculate probabilities
                probabilities = [];
                for (let possible_node of possible_nodes) {
                    probability = Math.pow(pheromone_matrix[current_node][possible_node], pheromone_influence) * Math.pow(apriori_matrix[current_node][possible_node], apriori_influence);
                    probabilities.push(probability);
                }

                // normalize probabilities to each node
                normalization = 0;
                for (let probability of probabilities) {
                    normalization += probability;
                }
                for (let i = 0; i < probabilities.length; i++) {
                    probabilities[i] /= normalization;
                }

                // choose next node based on probabilities
                choose_random = Math.random();
                cum_prob = 0;
                for (let i = 0; i < probabilities.length; i++) {
                    cum_prob += probabilities[i];
                    if (choose_random <= cum_prob) {
                        ant_paths[ant].push(possible_nodes[i]);
                        break;
                    }
                }
            }
        }

        // calculate path distance for each ant
        let ant_distances = [];
        let distance, current_node, next_node;
        for (let ant = 0; ant < num_ants; ant++) {
            distance = 0;
            for (let i = 0; i < ant_paths[ant].length - 1; i++) {
                current_node = ant_paths[ant][i];
                next_node = ant_paths[ant][i + 1];
                distance += getDistance(points[current_node].x, points[current_node].y, points[next_node].x, points[next_node].y);
            }

            // wrap around to form circular path
            current_node = ant_paths[ant][ant_paths[ant].length - 1];
            next_node = ant_paths[ant][0];
            distance += getDistance(points[current_node].x, points[current_node].y, points[next_node].x, points[next_node].y);
            
            ant_distances.push(distance);
        }

        let min_distance = Math.min(...ant_distances);
        let min_ant = -1;
        for (let ant = 0; ant < num_ants; ant++) {
            if (ant_distances[ant] == min_distance) {
                min_ant = ant;
                break;
            }
        }

        console.log(ant_distances);

        // update optimum solution
        optimum_solution = ant_paths[min_ant];

        // update pheromone matrix
        let pheromone_trails;
        for (let i = 0; i < pheromone_matrix.length; i++) {
            for (let j = i + 1; j < pheromone_matrix[i].length; j++) {
                pheromone_trails = 0;

                for (let ant = 0; ant < num_ants; ant++) {
                    if (hasAntTakenEdge(ant_paths[ant], i, j) || hasAntTakenEdge(ant_paths[ant], j, i)) {
                        pheromone_trails += rate / ant_distances[ant];
                    }
                }

                pheromone_matrix[i][j] = (1 - eva_factor) * pheromone_matrix[i][j] + pheromone_trails;
                pheromone_matrix[j][i] = pheromone_matrix[i][j];
            }
        }

        // update iteration
        iteration += 1
        if (iteration >= num_iterations) {
            running = false;
        }
    }
}

function updateParams(variable) {
    if (variable == "num") {
        num_ants = num_input.value;
        num_display.innerHTML = `Number of ants: ${num_ants}<br>(if changed, simulation will restart)`;

        if (running) {
            initSimulation();
        }
    }
    if (variable == "eva") {
        eva_factor = eva_input.value;
        eva_display.innerHTML = `Evaporation factor (&rho;): ${eva_factor}`;
    }
    if (variable == "phe") {
        pheromone_influence = phe_input.value;
        phe_display.innerHTML = `Pheromone influence (&alpha;): ${pheromone_influence}`;
    }
    if (variable == "apr") {
        apriori_influence = apr_input.value;
        apr_display.innerHTML = `<em>A priori</em> influence (&beta;): ${apriori_influence}`;
    }
}

function initSimulation() {
    if (points.length > 3) {
        apriori_matrix = new2dArray(points.length, points.length);
        for (let i = 0; i < points.length; i++) {
            for (let j = 0; j < points.length; j++) {
                if (i != j) {
                    apriori_matrix[i][j] = 1 / getDistance(points[i].x, points[i].y, points[j].x, points[j].y);
                }
                else {
                    apriori_matrix[i][j] = 0;
                }
            }
        }

        pheromone_matrix = new2dArray(points.length, points.length);
        for (let i = 0; i < points.length; i++) {
            for (let j = 0; j < points.length; j++) {
                pheromone_matrix[i][j] = 1;
            }
        }

        ant_paths = [];
        for (let i = 0; i < num_ants; i++) {
            ant_paths.push([]);
        }

        optimum_solution = [];

        iteration = 0;
        running = true;
    }
}

function placeAnts() {
    ant_paths = []

    let node;
    for (let i = 0; i < num_ants; i++) {
        node = randInt(0, points.length);
        ant_paths.push([node]);
    }
}

function hasAntTakenEdge(path, node1, node2) {
    for (let i = 0; i < path.length - 1; i++) {
        if (path[i] == node1 && path[i + 1] == node2) {
            return true;
        }

    }

    if (path[path.length - 1] == node1 && path[0] == node2) {
        return true;
    }

    return false;
}

function initParams() {
    points = [];
    optimum_solution = [];

    if (mobile) {
        near_cutoff = 5;
    }
    else {
        near_cutoff = 7;
    }
    
    running = false;
    num_iterations = 200;
    rate = canvas_width;

    updateParams("num");
    updateParams("eva");
    updateParams("phe");
    updateParams("apr");

    for (let i = 0; i < 20; i++) {
        randomPoint();
    }
    initSimulation();
}

function clickedAt(x, y) {
    if (!running) {
        let distance = 0;
        let point_nearby = false;
        for (let point of points) {
            distance = getDistance(x, y, point.x, point.y);
            if (distance < near_cutoff) {
                points = removeElement(points, point);
                point_nearby = true;
                break;
            }
        }

        if (!point_nearby) {
            points.push({ x: Math.round(x), y: Math.round(y) });
            optimum_solution = [];
        }
    }
}

function randomPoint() {
    if (!running) {
        let x = randInt(0, canvas_width);
        let y = randInt(0, canvas_height);
        points.push({ x: x, y: y });
        optimum_solution = [];
    }
}

function pathContainsNode(path, node) {
    for (let i = 0; i < path.length; i++) {
        if (path[i] == node) {
            return true;
        }
    }
    return false;
}

function clearPoints() {
    if (!running) {
        points = [];
        optimum_solution = [];
    }
}


================================================
FILE: ant_colony_optimization/user_input.js
================================================
function clicked() {
    clickedAt(click_x, click_y);
}

function moved() {

}

function released() {

}

function keyPressed(key) {

}

function keyReleased(key) {
    
}


================================================
FILE: artificial_life/basic.js
================================================
let screen_width = window.innerWidth, screen_height = window.innerHeight;
let canvas_width, canvas_height;
let fps = 24, paused = false;
let mobile;

if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
    mobile = true;
} else {
    mobile = false;
}

let canvas = document.getElementById("canvas");
let context = canvas.getContext("2d");

let interaction_elements = {
    "red": {
        "red": document.getElementById('red-red'),
        "blue": document.getElementById('red-blue'),
        "orange": document.getElementById('red-orange'),
        "white": document.getElementById('red-white'),
    },
    "blue": {
        "red": document.getElementById('blue-red'),
        "blue": document.getElementById('blue-blue'),
        "orange": document.getElementById('blue-orange'),
        "white": document.getElementById('blue-white'),
    },
    "orange": {
        "red": document.getElementById('orange-red'),
        "blue": document.getElementById('orange-blue'),
        "orange": document.getElementById('orange-orange'),
        "white": document.getElementById('orange-white'),
    },
    "white": {
        "red": document.getElementById('white-red'),
        "blue": document.getElementById('white-blue'),
        "orange": document.getElementById('white-orange'),
        "white": document.getElementById('white-white'),
    },
}

let interaction_displays = {
    "red": {
        "red": document.getElementById('red-red-display'),
        "blue": document.getElementById('red-blue-display'),
        "orange": document.getElementById('red-orange-display'),
        "white": document.getElementById('red-white-display'),
    },
    "blue": {
        "red": document.getElementById('blue-red-display'),
        "blue": document.getElementById('blue-blue-display'),
        "orange": document.getElementById('blue-orange-display'),
        "white": document.getElementById('blue-white-display'),
    },
    "orange": {
        "red": document.getElementById('orange-red-display'),
        "blue": document.getElementById('orange-blue-display'),
        "orange": document.getElementById('orange-orange-display'),
        "white": document.getElementById('orange-white-display'),
    },
    "white": {
        "red": document.getElementById('white-red-display'),
        "blue": document.getElementById('white-blue-display'),
        "orange": document.getElementById('white-orange-display'),
        "white": document.getElementById('white-white-display'),
    }
}

let status_elements = {
    "red": document.getElementById('red-status'),
    "blue": document.getElementById('blue-status'),
    "orange": document.getElementById('orange-status'),
    "white": document.getElementById('white-status'),
}

let damping_input = document.getElementById('damping-input');
let damping_display = document.getElementById('damping-display');

let cutoff_input = document.getElementById('cutoff-input');
let cutoff_display = document.getElementById('cutoff-display');

if (mobile) {
    canvas_width = 0.9 * screen_width;
}
else {
    canvas_width = 0.45 * screen_width;
}
canvas_height = canvas_width;

canvas.width = canvas_width;
canvas.height = canvas_height;

let animate = window.requestAnimationFrame
    || window.webkitRequestAnimationFrame
    || window.mozRequestAnimationFrame
    || function (callback) {
        window.setTimeout(callback, 1000 / fps);
    };

function step() {
    if (!paused) {
        update();
    }
    render();
    animate(step);
}

window.onload = function () {
    defaultParams();
    initParams();
    animate(step);
}

function defaultParams() {
    num_red = 200;
    num_blue = 200;
    num_green = 200;
    num_white = 200;

    damping_input.value = 0.2;

    cutoff_input.min = Number.parseInt(canvas_width / 10);
    cutoff_input.max = Number.parseInt(canvas_width / 2);
    cutoff_input.value = Number.parseInt(canvas_width / 6);
}

let click_x, click_y, pressed;

if(mobile) {
    canvas.addEventListener("touchstart", function (e) {
        getTouchPosition(canvas, e);
        let touch = e.touches[0];
        let mouseEvent = new MouseEvent("mousedown", {
            clientX: touch.clientX,
            clientY: touch.clientY
        });
        canvas.dispatchEvent(mouseEvent);
        pressed = true;
        clicked();
    }, false);

    canvas.addEventListener("touchmove", function (e) {
        getTouchPosition(canvas, e);
        let touch = e.touches[0];
        let mouseEvent = new MouseEvent("mousemove", {
            clientX: touch.clientX,
            clientY: touch.clientY
        });
        canvas.dispatchEvent(mouseEvent);
        moved();
    }, false);

    canvas.addEventListener("touchend", function (e) {
        getTouchPosition(canvas, e);
        let touch = e.touches[0];
        let mouseEvent = new MouseEvent("mouseup", {
            clientX: touch.clientX,
            clientY: touch.clientY
        });
        canvas.dispatchEvent(mouseEvent);
        pressed = false;
        released();
    }, false);
}
else {
    canvas.addEventListener("mousedown", function (e) {
        getMousePosition(canvas, e);
        pressed = true;
        clicked();
    });

    canvas.addEventListener("mousemove", function (e) {
        getMousePosition(canvas, e);
        moved();
    });

    canvas.addEventListener("mouseup", function (e) {
        getMousePosition(canvas, e);
        pressed = false;
        released();
    });

    window.addEventListener("keydown", function(e) {
        keyPressed(e.keyCode);
    }, false);

    window.addEventListener("keydown", function(e) {
        keyReleased(e.keyCode);
    }, false);
}

function getMousePosition(canvas, event) {
    rect = canvas.getBoundingClientRect();
    click_x = event.clientX - rect.left;
    click_y = event.clientY - rect.top;
}

function getTouchPosition(canvas, event) {
    var rect = canvas.getBoundingClientRect();
    click_x = event.touches[0].clientX - rect.left;
    click_y = event.touches[0].clientY - rect.top;
}


================================================
FILE: artificial_life/Particle.js
================================================
class Particle {
    constructor(x, y, color) {
        this.x = x;
        this.y = y;
        this.color = color;

        this.vx = 0;
        this.vy = 0;
    }

    applyForce(fx, fy) {
        this.vx = (this.vx + fx) * (1 - damping);
        this.vy = (this.vy + fy) * (1 - damping);
    }

    update() {
        this.x += this.vx;
        this.y += this.vy;

        if (this.x < 0) {
            this.x = 0;
            this.vx *= -1;
        }
        else if (this.x > canvas_width) {
            this.x = canvas_width;
            this.vx *= -1;
        }
        if (this.y < 0) {
            this.y = 0;
            this.vy *= -1;
        }
        else if (this.y > canvas_height) {
            this.y = canvas_height;
            this.vy *= -1;
        }
    }

    render() {
        context.fillStyle = this.color;
        context.fillRect(this.x, this.y, particle_size, particle_size);
    }
}


================================================
FILE: artificial_life/simulation.html
================================================
<!DOCTYPE html>
<html lang="en-US">

<head>
  <title>Artificial Life | Visualize It</title>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Materialize -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/js/materialize.min.js"></script>

  <script src="../helper.js" defer></script>
  <script src="basic.js" defer></script>
  <script src="user_input.js" defer></script>
  <script src="simulation.js" defer></script>
  <script src="Particle.js" defer></script>

  <script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML">
    </script>

  <!-- CSS -->
  <link rel="stylesheet" href="../style.css" />
</head>

<script async src="https://www.googletagmanager.com/gtag/js?id=G-M95CKRP8HB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() { window.dataLayer.push(arguments); }
  gtag('js', new Date());

  gtag('config', 'G-M95CKRP8HB');
</script>

<body>
  <nav class="nav-extended" style="background:black; margin-top: 0mm">
    <div class="nav-wrapper">
      <h1 id="main-heading">Visualize It</h1>
    </div>
    <div class="nav-content">
      <ul class="tabs tabs-transparent tabs-fixed-width">
        <li class="tab"><a href="../index.html" style="font-size: larger;">Home</a></li>
        <li class="tab"><a href="../about.html" style="font-size: larger;">About</a></li>
      </ul>
    </div>
  </nav>

  <div class="text">
    <h2>Artificial Life</h2>

    <div class="container" style="width:90%">
      <div class="row">
        <div class="col s12 l8">
          <canvas id="canvas"></canvas>
          <br>
          <center>
            <button class="btn purple darken-4" onclick="initParams()">Restart</button>
            <button class="btn purple darken-4" onclick="presets('reset')">Reset</button>
            <br> <br>
            <label style="margin-right:20px">
              <input type="checkbox" id="red-status" onchange="updateStatus('red')" checked/>
              <span>Red</span>
            </label>
            <label style="margin-right:20px">
              <input type="checkbox" id="blue-status" onchange="updateStatus('blue')" checked/>
              <span>Blue</span>
            </label>
            <label style="margin-right:20px">
              <input type="checkbox" id="orange-status" onchange="updateStatus('orange')" checked/>
              <span>Orange</span>
            </label>
            <label style="margin-right:20px">
              <input type="checkbox" id="white-status" onchange="updateStatus('white')" checked/>
              <span>White</span>
            </label>
            <br>
            <div class="col s6 l6">
              <span id="damping-display"></span>
              <input id="damping-input" type="range" min="0" max="0.9" step="0.1" oninput="updateParams('damping')" onchange="updateParams('damping')">
            </div>
            <div class="col s6 l6">
              <span id="cutoff-display"></span>
              <input id="cutoff-input" type="range" min="10" max="100" step="1" oninput="updateParams('cutoff')" onchange="updateParams('cutoff')">
            </div>
          </center>
        </div>
        <div class="col s12 l4">
          <center>
            <b>Interaction Strengths:</b>
          </center>
          <div class="col s6 l6">
            <span id="red-red-display">Red with Red:</span>
            <input type="range" min="-1" max="1" step="0.01" id="red-red" oninput="updateInteraction('red', 'red')"
              onchange="updateInteraction('red', 'red')" />
            <span id="red-blue-display">Red with Blue:</span>
            <input type="range" min="-1" max="1" step="0.01" id="red-blue" oninput="updateInteraction('red', 'blue')"
              onchange="updateInteraction('red', 'blue')" />
            <span id="red-orange-display">Red with Orange:</span>
            <input type="range" min="-1" max="1" step="0.01" id="red-orange"
              oninput="updateInteraction('red', 'orange')" onchange="updateInteraction('red', 'orange')" />
            <span id="red-white-display">Red with White:</span>
            <input type="range" min="-1" max="1" step="0.01" id="red-white" oninput="updateInteraction('red', 'white')"
              onchange="updateInteraction('red', 'white')" />

            <br> <br>

            <span id="orange-red-display">Orange with Red:</span>
            <input type="range" min="-1" max="1" step="0.01" id="orange-red"
              oninput="updateInteraction('orange', 'red')" onchange="updateInteraction('orange', 'red')" />
            <span id="orange-blue-display">Orange with Blue:</span>
            <input type="range" min="-1" max="1" step="0.01" id="orange-blue"
              oninput="updateInteraction('orange', 'blue')" onchange="updateInteraction('orange', 'blue')" />
            <span id="orange-orange-display">Orange with Orange:</span>
            <input type="range" min="-1" max="1" step="0.01" id="orange-orange"
              oninput="updateInteraction('orange', 'orange')" onchange="updateInteraction('orange', 'orange')" />
            <span id="orange-white-display">Orange with White:</span>
            <input type="range" min="-1" max="1" step="0.01" id="orange-white"
              oninput="updateInteraction('orange', 'white')" onchange="updateInteraction('orange', 'white')" />
          </div>
          <div class="col s6 l6">
            <span id="blue-red-display">Blue with Red:</span>
            <input type="range" min="-1" max="1" step="0.01" id="blue-red" oninput="updateInteraction('blue', 'red')"
              onchange="updateInteraction('blue', 'red')" />
            <span id="blue-blue-display">Blue with Blue:</span>
            <input type="range" min="-1" max="1" step="0.01" id="blue-blue" oninput="updateInteraction('blue', 'blue')"
              onchange="updateInteraction('blue', 'blue')" />
            <span id="blue-orange-display">Blue with Orange:</span>
            <input type="range" min="-1" max="1" step="0.01" id="blue-orange"
              oninput="updateInteraction('blue', 'orange')" onchange="updateInteraction('blue', 'orange')" />
            <span id="blue-white-display">Blue with White:</span>
            <input type="range" min="-1" max="1" step="0.01" id="blue-white"
              oninput="updateInteraction('blue', 'white')" onchange="updateInteraction('blue', 'white')" />

            <br> <br>

            <span id="white-red-display">White with Red:</span>
            <input type="range" min="-1" max="1" step="0.01" id="white-red" oninput="updateInteraction('white', 'red')"
              onchange="updateInteraction('white', 'red')" />
            <span id="white-blue-display">White with Blue:</span>
            <input type="range" min="-1" max="1" step="0.01" id="white-blue"
              oninput="updateInteraction('white', 'blue')" onchange="updateInteraction('white', 'blue')" />
            <span id="white-orange-display">White with Orange:</span>
            <input type="range" min="-1" max="1" step="0.01" id="white-orange"
              oninput="updateInteraction('white', 'orange')" onchange="updateInteraction('white', 'orange')" />
            <span id="white-white-display">White with White:</span>
            <input type="range" min="-1" max="1" step="0.01" id="white-white"
              oninput="updateInteraction('white', 'white')" onchange="updateInteraction('white', 'white')" />
          </div>
        </div>
      </div>
    </div>

    <center>
      <button class="btn purple darken-4" onclick="presets('cell')">Cells</button>
      <button class="btn purple darken-4" onclick="presets('swimmers')">Swimmers</button>
      <button class="btn purple darken-4" onclick="presets('membrane')">Membrane</button>
    </center>


    <br>
    <hr>

    <p class="center-align">Developed by ChanRT | Fork me at <a href="https://www.github.com/chanrt">GitHub</a></p>
  </div>
</body>

</html>


================================================
FILE: artificial_life/simulation.js
================================================
let particles = [];

let num_red, num_blue, num_green, num_white;

let cutoff_length, damping;

let particle_size = 4;

let colors = ["red", "blue", "orange", "white"];

let statuses = {
    "red": true,
    "blue": true,
    "orange": true,
    "white": true,
}

let interactions = {
    "red": {
        "red": 0,
        "blue": 0,
        "orange": 0,
        "white": 0,
    },
    "blue": {
        "red": 0,
        "blue": 0,
        "orange": 0,
        "white": 0,
    },
    "orange": {
        "red": 0,
        "blue": 0,
        "orange": 0,
        "white": 0,
    },
    "white": {
        "red": 0,
        "blue": 0,
        "orange": 0,
        "white": 0,
    }
}

function update() {
    for (let particle of particles) {
        if (statuses[particle.color]) {
            let fx = 0, fy = 0;

            for (let other_particle of particles) {
                let dx = particle.x - other_particle.x;
                let dy = particle.y - other_particle.y;
                let dist = Math.sqrt(dx * dx + dy * dy);

                if (dist > 0 && dist < cutoff_length) {
                    let force = interactions[particle.color][other_particle.color] / dist;
                    fx += force * dx;
                    fy += force * dy;
                }
            }
            particle.applyForce(fx, fy);
        }
    }

    for (let particle of particles) {
        particle.update();
    }
}

function render() {
    context.fillStyle = "black";
    context.fillRect(0, 0, canvas_width, canvas_height);

    for (let particle of particles) {
        if (statuses[particle.color]) {
            particle.render();
        }
    }
}

function updateInteraction(color1, color2) {
    element = interaction_elements[color1][color2];
    value = parseFloat(element.value);

    console.log(value);

    if (!Number.isNaN(value)) {
        console.log("assigning");
        interactions[color1][color2] = value;
        interaction_displays[color1][color2].innerHTML = `${color1} with ${color2}: ${interactions[color1][color2]}`;
    }
}

function updateStatus(color) {
    if (status_elements[color].checked) {
        statuses[color] = true;
    }
    else {
        statuses[color] = false;
        for (let color1 of colors) {
            for (let color2 of colors) {
                if (color1 == color || color2 == color) {
                    interactions[color1][color2] = 0;
                    interactions[color2][color1] = 0;

                    interaction_elements[color1][color2].value = 0;
                    interaction_elements[color2][color1].value = 0;
                }
            }
        }
    }

}

function updateParams(variable) {
    if (variable == "damping") {
        damping = damping_input.value;
        damping_display.innerHTML = `Damping: ${damping}`;
    }
    if (variable == "cutoff") {
        cutoff_length = cutoff_input.value;
        cutoff_display.innerHTML = `Cutoff: ${cutoff_length}`;
    }
}

function makeParticles(num, color) {
    for (let i = 0; i < num; i++) {
        let x = 0.1 * canvas_width + 0.8 * (Math.random() * canvas_width);
        let y = 0.1 * canvas_height + 0.8 * (Math.random() * canvas_height);
        particles.push(new Particle(x, y, color));
    }
}

function initParams() {
    particles = [];

    updateParams('cutoff');
    updateParams('damping');

    makeParticles(num_red, "red");
    makeParticles(num_blue, "blue");
    makeParticles(num_green, "orange");
    makeParticles(num_white, "white");

    for (let color1 of colors) {
        for (let color2 of colors) {
            interaction_elements[color1][color2].value = interactions[color1][color2];
            interaction_displays[color1][color2].innerHTML = `${color1} with ${color2}: ${interactions[color1][color2]}`;
        }
    }

    for (let color of colors) {
        status_elements[color].checked = statuses[color];
    }
}

function presets(name) {
    if (name == "cell") {
        interactions = {
            "red": {
                "red": -0.3,
                "blue": 0.2,
                "orange": 0,
                "white": 0,
            },
            "blue": {
                "red": 0.3,
                "blue": 0.01,
                "orange": 0,
                "white": 0,
            },
            "orange": {
                "red": 0,
                "blue": 0,
                "orange": 0,
                "white": 0,
            },
            "white": {
                "red": 0,
                "blue": 0,
                "orange": 0,
                "white": 0,
            }
        };

        statuses = {
            "red": true,
            "blue": true,
            "orange": false,
            "white": false,
        };

        num_red = 200;
        num_blue = 500;

        damping_input.value = 0.2;
        cutoff_input.value = canvas_width / 10;

        initParams();
    }
    else if (name == "propulsion") {
        interactions = {
            "red": {
                "red": -0.1,
                "blue": -0.34,
                "orange": 0,
                "white": 0,
            },
            "blue": {
                "red": -0.17,
                "blue": -0.32,
                "orange": 0.34,
                "white": 0,
            },
            "orange": {
                "red": 0,
                "blue": -0.2,
                "orange": 0.15,
                "white": 0,
            },
            "white": {
                "red": 0,
                "blue": 0,
                "orange": 0,
                "white": 0,
            }
        };
        statuses = {
            "red": true,
            "blue": true,
            "orange": true,
            "white": false,
        };

        num_red = 100;
        num_blue = 100;
        num_orange = 500;

        damping_input.value = 0.5;
        cutoff_input.value = canvas_width / 5;

        initParams();
    }
    else if (name == "swimmers") {
        interactions = {
            "red": {
                "red": -0.3,
                "blue": 0.2,
                "orange": 0.2,
                "white": 0,
            },
            "blue": {
                "red": 0.3,
                "blue": 0.01,
                "orange": -0.01,
                "white": 0,
            },
            "orange": {
                "red": -0.05,
                "blue": 0.01,
                "orange": 0.01,
                "white": 0,
            },
            "white": {
                "red": 0,
                "blue": 0,
                "orange": 0,
                "white": 0,
            }
        };

        statuses = {
            "red": true,
            "blue": true,
            "orange": true,
            "white": false,
        };

        num_red = 200;
        num_orange = 350;
        num_blue = 500;

        damping_input.value = 0.3;
        cutoff_input.value = canvas_width / 10;

        initParams();
    }
    else if (name == 'reset') {
        interactions = {
            "red": {
                "red": 0,
                "blue": 0,
                "orange": 0,
                "white": 0,
            },
            "blue": {
                "red": 0,
                "blue": 0,
                "orange": 0,
                "white": 0,
            },
            "orange": {
                "red": 0,
                "blue": 0,
                "orange": 0,
                "white": 0,
            },
            "white": {
                "red": 0,
                "blue": 0,
                "orange": 0,
                "white": 0,
            }
        };

        statuses = {
            "red": true,
            "blue": true,
            "orange": true,
            "white": true,
        };

        num_blue = 200;
        num_red = 200;
        num_orange = 200;
        num_white = 200;

        damping_input.value = 0.2;
        cutoff_input.value = canvas_width / 6;

        initParams();
    }
    else if (name == 'membrane') {
        interactions = {
            "red": {
                "red": 0,
                "blue": 0,
                "orange": 0,
                "white": 0,
            },
            "blue": {
                "red": 0,
                "blue": 0,
                "orange": 0,
                "white": 0,
            },
            "orange": {
                "red": 0,
                "blue": 0,
                "orange": -0.2,
                "white": -0.2,
            },
            "white": {
                "red": 0,
                "blue": 0,
                "orange": -0.5,
                "white": -1,
            }
        };

        statuses = {
            "red": false,
            "blue": false,
            "orange": true,
            "white": true,
        };

        num_orange = 200;
        num_white = 500;

        damping_input.value = 0.7;
        cutoff_input.value = canvas_width / 2;;

        initParams();
    }
}


================================================
FILE: artificial_life/user_input.js
================================================
function clicked() {

}

function moved() {

}

function released() {

}

function keyPressed(key) {

}

function keyReleased(key) {
    
}


================================================
FILE: bernoulli_percolation/basic.js
================================================
let screen_width = window.innerWidth, screen_height = window.innerHeight;
let canvas_width, canvas_height;
let fps = 24, paused = false;
let mobile;

if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
    mobile = true;
} else {
    mobile = false;
}

let canvas = document.getElementById("canvas");
let context = canvas.getContext("2d");

let prob_input = document.getElementById("prob-input");
let prob_display = document.getElementById("prob-display");

if (mobile) {
    canvas_width = 0.9 * screen_width;
}
else {
    canvas_width = 0.45 * screen_width;
}
canvas_height = canvas_width;

canvas.width = canvas_width;
canvas.height = canvas_height;

let animate = window.requestAnimationFrame
    || window.webkitRequestAnimationFrame
    || window.mozRequestAnimationFrame
    || function (callback) {
        window.setTimeout(callback, 1000 / fps);
    };

function step() {
    if (!paused) {
        update();
    }
    render();
    animate(step);
}

window.onload = function () {
    defaultParams();
    initParams();
    animate(step);
}

function defaultParams() {
    prob_input.value = 0.4;
}

let click_x, click_y, pressed;

if(mobile) {
    canvas.addEventListener("touchstart", function (e) {
        getTouchPosition(canvas, e);
        let touch = e.touches[0];
        let mouseEvent = new MouseEvent("mousedown", {
            clientX: touch.clientX,
            clientY: touch.clientY
        });
        canvas.dispatchEvent(mouseEvent);
        pressed = true;
        clicked();
    }, false);

    canvas.addEventListener("touchmove", function (e) {
        getTouchPosition(canvas, e);
        let touch = e.touches[0];
        let mouseEvent = new MouseEvent("mousemove", {
            clientX: touch.clientX,
            clientY: touch.clientY
        });
        canvas.dispatchEvent(mouseEvent);
        moved();
    }, false);

    canvas.addEventListener("touchend", function (e) {
        getTouchPosition(canvas, e);
        let touch = e.touches[0];
        let mouseEvent = new MouseEvent("mouseup", {
            clientX: touch.clientX,
            clientY: touch.clientY
        });
        canvas.dispatchEvent(mouseEvent);
        pressed = false;
        released();
    }, false);
}
else {
    canvas.addEventListener("mousedown", function (e) {
        getMousePosition(canvas, e);
        pressed = true;
        clicked();
    });

    canvas.addEventListener("mousemove", function (e) {
        getMousePosition(canvas, e);
        moved();
    });

    canvas.addEventListener("mouseup", function (e) {
        getMousePosition(canvas, e);
        pressed = false;
        released();
    });

    window.addEventListener("keydown", function(e) {
        keyPressed(e.keyCode);
    }, false);

    window.addEventListener("keydown", function(e) {
        keyReleased(e.keyCode);
    }, false);
}

function getMousePosition(canvas, event) {
    rect = canvas.getBoundingClientRect();
    click_x = event.clientX - rect.left;
    click_y = event.clientY - rect.top;
}

function getTouchPosition(canvas, event) {
    var rect = canvas.getBoundingClientRect();
    click_x = event.touches[0].clientX - rect.left;
    click_y = event.touches[0].clientY - rect.top;
}


================================================
FILE: bernoulli_percolation/simulation.html
================================================
<!DOCTYPE html>
<html lang="en-US">

<head>
  <title>Bernoulli Percolation | Visualize It</title>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="keywords" content="percolation, percolation transition, bernoulli percolation, interactive, simulation">
  <meta name="og:image"
    content="https://github.com/visualize-it/visualize-it.github.io/raw/main/images_webp/bernoulli_percolation.webp">

  <!-- Materialize -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/js/materialize.min.js"></script>

  <script src="../helper.js" defer></script>
  <script src="basic.js" defer></script>
  <script src="user_input.js" defer></script>
  <script src="simulation.js" defer></script>

  <script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML">
    </script>

  <!-- CSS -->
  <link rel="stylesheet" href="../style.css" />
</head>

<script async src="https://www.googletagmanager.com/gtag/js?id=G-M95CKRP8HB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() { window.dataLayer.push(arguments); }
  gtag('js', new Date());

  gtag('config', 'G-M95CKRP8HB');
</script>

<body>
  <nav class="nav-extended" style="background:black; margin-top: 0mm">
    <div class="nav-wrapper">
      <h1 id="main-heading">Visualize It</h1>
    </div>
    <div class="nav-content">
      <ul class="tabs tabs-transparent tabs-fixed-width">
        <li class="tab"><a href="../index.html" style="font-size: larger;">Home</a></li>
        <li class="tab"><a href="../about.html" style="font-size: larger;">About</a></li>
      </ul>
    </div>
  </nav>

  <div class="text">
    <h2>Bernoulli Percolation</h2>
    <p>
      <center>
        Percolation is the study of flow of fluid through porous media. Bernoulli percolation is a very simple model
        that features a widely-studied phase transition. The model comprises of a two dimensional grid of cell. The
        probability that the 'gate' between two cells is open, is given by the percolation probability. A connected
        group of cells will have the same colored fluid.
      </center>
    </p>
    <br>

    <div class="container" style="width:90%">
      <div class="row">
        <div class="col s12 l8">
          <canvas id="canvas"></canvas>
        </div>
        <div class="col s12 l4">
          <div style="background:black; padding: 15px; border: 2px red solid;">
            <center>
              <b>Warning:</b>
              This simulation features rapidly strobing lights. It is not recommended for people with photosensitive
              epilepsy.
            </center>
          </div>
          <center>
            <p id="prob-display"></p>
            <input id="prob-input" min="0" max="1" step="0.01" type="range" oninput="updateParams('prob')"
              onchange="updateParams('prob')" />
            <br> <br>
            <button class="btn purple darken-4" onclick="initParams()">Reset</button>
            <br>
            <hr>
            <p>
              Vary the percolation probability from 0 to 1. Around 0.5, you should notice that a connected system that
              spans the entire landscape has come into existence. This cluster is called 'percolating cluster' or
              'spanning cluster', and this transition is called 'percolation transition'.
            </p>
          </center>
        </div>
      </div>
    </div>

    <br>
    <hr>
    <br>

    <b>Note:</b>
    <ol>
      <li>From 0.5 onwards, the dominant cluster changes color very often because it merges with many smaller cells with
        differently colored fluids.</li>
      <li>
        This simulation is computationally complex and may lag on lower end devices.
      </li>
      <li>
        Related: <a href="../porous_percolation/simulation.html">Porous Percolation</a>, 
        <a href="../tdp/simulation.html">Directed Percolation</a>, 
        <a href="../contact_process/simulation.html">Contact Process</a>.
      </li>
    </ol>

    <br>
    <hr>

    <p class="center-align">Developed by ChanRT | Fork me at <a href="https://www.github.com/chanrt">GitHub</a></p>
  </div>
</body>

</html>


================================================
FILE: bernoulli_percolation/simulation.js
================================================
let cells = [];
let num_cells, cell_length;

let percolation_probability;

function update() {
    
}

function render() {
    context.fillStyle = "#ffffff";
    context.fillRect(0, 0, canvas_width, canvas_height);

    drawCells();
    drawGates();
}

function updateParams(variable) {
    if (variable == "prob") {
        percolation_probability = parseFloat(prob_input.value);
        prob_display.innerHTML = `Percolation Probability = ${percolation_probability.toFixed(2)}`;
        openGates();
    }
}

function initParams() {
    if (mobile) {
        num_cells = 50;
    }
    else {
        num_cells = 80;
    }

    cell_length = canvas_width / num_cells;
    makeCells();

    updateParams('prob');
    openGates();
}

function openGates() {
    for (let i = 0; i < num_cells; i++) {
        for (let j = 0; j < num_cells; j++) {
            if (cells[i][j].right < percolation_probability) {
                // right gate should be open
                if (!cells[i][j].right_open) {
                    cells[i][j].right_open = true;
                    cells[i][(j + 1) % num_cells].left_open = true;

                    if (cells[i][j].color != cells[i][(j + 1) % num_cells].color) {
                        cells[i][(j + 1) % num_cells].color = cells[i][j].color;
                        percolate(i, (j + 1) % num_cells);
                    }
                }
            }
            else {
                // right gate should be closed
                if (cells[i][j].right_open) {
                    cells[i][j].right_open = false;
                    cells[i][(j + 1) % num_cells].left_open = false;

                    if (cells[i][j].color == cells[i][(j + 1) % num_cells].color) {
                        cells[i][(j + 1) % num_cells].color = getRandomColor();
                        percolate(i, (j + 1) % num_cells);
                    }
                }
            }
            if (cells[i][j].bottom < percolation_probability) {
                // bottom gate should be open
                if (!cells[i][j].bottom_open) {
                    cells[i][j].bottom_open = true;
                    cells[(i + 1) % num_cells][j].top_open = true;

                    if (cells[i][j].color != cells[(i + 1) % num_cells][j].color) {
                        cells[(i + 1) % num_cells][j].color = cells[i][j].color;
                        percolate((i + 1) % num_cells, j);
                    }
                }
            }
            else {
                // bottom gate should be closed
                if (cells[i][j].bottom_open) {
                    cells[i][j].bottom_open = false;
                    cells[(i + 1) % num_cells][j].top_open = false;

                    if (cells[i][j].color == cells[(i + 1) % num_cells][j].color) {
                        cells[(i + 1) % num_cells][j].color = getRandomColor();
                        percolate((i + 1) % num_cells, j);
                    }
                }
            }
        }
    }
}

function percolate(i, j) {
    let percolate_stack = [[i, j]];

    while (percolate_stack.length > 0) {
        let cell = percolate_stack.pop();
        let i = cell[0];
        let j = cell[1];

        if (cells[i][j].top_open) {
            if (cells[i][j].color != cells[(i + num_cells - 1) % num_cells][j].color) {
                cells[(i + num_cells - 1) % num_cells][j].color = cells[i][j].color;
                percolate_stack.push([(i + num_cells - 1) % num_cells, j]);
            }
        }
        if (cells[i][j].right_open) {
            if (cells[i][j].color != cells[i][(j + 1) % num_cells].color) {
                cells[i][(j + 1) % num_cells].color = cells[i][j].color;
                percolate_stack.push([i, (j + 1) % num_cells]);
            }
        }
        if (cells[i][j].bottom_open) {
            if (cells[i][j].color != cells[(i + 1) % num_cells][j].color) {
                cells[(i + 1) % num_cells][j].color = cells[i][j].color;
                percolate_stack.push([(i + 1) % num_cells, j]);
            }
        }
        if (cells[i][j].left_open) {
            if (cells[i][j].color != cells[i][(j + num_cells - 1) % num_cells].color) {
                cells[i][(j + num_cells - 1) % num_cells].color = cells[i][j].color;
                percolate_stack.push([i, (j + num_cells - 1) % num_cells]);
            }
        }
    }
}

function drawCells() {
    for (let i = 0; i < num_cells; i++) {
        for (let j = 0; j < num_cells; j++) {
            context.fillStyle = cells[i][j].color;
            context.fillRect(j * cell_length, i * cell_length, cell_length, cell_length);
        }
    }
}

function drawGates() {
    context.strokeStyle = "#000000";
    context.lineWidth = 2;

    for (let i = 0; i < num_cells; i++) {
        for (let j = 0; j < num_cells; j++) {
            if (!cells[i][j].top_open) {
                context.beginPath();
                context.moveTo(j * cell_length, i * cell_length);
                context.lineTo((j + 1) * cell_length, i * cell_length);
                context.stroke();
            }
            if (!cells[i][j].right_open) {
                context.beginPath();
                context.moveTo((j + 1) * cell_length, i * cell_length);
                context.lineTo((j + 1) * cell_length, (i + 1) * cell_length);
                context.stroke();
            }
            if (!cells[i][j].bottom_open) {
                context.beginPath();
                context.moveTo(j * cell_length, (i + 1) * cell_length);
                context.lineTo((j + 1) * cell_length, (i + 1) * cell_length);
                context.stroke();
            }
            if (!cells[i][j].left_open) {
                context.beginPath();
                context.moveTo(j * cell_length, i * cell_length);
                context.lineTo(j * cell_length, (i + 1) * cell_length);
                context.stroke();
            }
        }
    }
}

function getRandomColor() {
    let color = "rgb(";
    color += Math.floor(56 + Math.random() * 200) + ", ";
    color += Math.floor(56 + Math.random() * 200) + ", ";
    color += Math.floor(56 + Math.random() * 200) + ")";
    return color;
}

function makeCells() {
    cells = [];
    for (let i = 0; i < num_cells; i++) {
        new_row = [];
        for (let j = 0; j < num_cells; j++) {
            new_cell = {
                bottom: Math.random(),
                right: Math.random(),
                
                top_open: false,
                right_open: false,
                bottom_open: false,
                left_open: false,

                color: getRandomColor(),
            };
            new_row.push(new_cell);
        }
        cells.push(new_row);
    }
}


================================================
FILE: bernoulli_percolation/user_input.js
================================================
function clicked() {

}

function moved() {

}

function released() {

}

function keyPressed(key) {

}

function keyReleased(key) {
    
}


================================================
FILE: bezier_curves/basic.js
================================================
let screen_width = window.innerWidth, screen_height = window.innerHeight;
let fps = 24;

let canvas = document.getElementById("canvas");
let context = canvas.getContext("2d");

if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
    mobile = true;
} else {
    mobile = false;
}

if (mobile) {
    canvas_width = 0.9 * screen_width;

    canvas.addEventListener("touchstart", function (e) {
        getTouchPosition(canvas, e);
        let touch = e.touches[0];
        let mouseEvent = new MouseEvent("mousedown", {
            clientX: touch.clientX,
            clientY: touch.clientY
        });
        canvas.dispatchEvent(mouseEvent);
        clicked();
    }, false);

    canvas.addEventListener("touchmove", function (e) {
        getTouchPosition(canvas, e);
        let touch = e.touches[0];
        let mouseEvent = new MouseEvent("mousemove", {
            clientX: touch.clientX,
            clientY: touch.clientY
        });
        canvas.dispatchEvent(mouseEvent);
        moved();
    }, false);
} else {
    canvas_width = 0.35 * screen_width;

    canvas.addEventListener("mousedown", function (e) {
        getMousePosition(canvas, e);
        clicked(canvas, e);
    });

    canvas.addEventListener("mouseup", function (e) {
        getMousePosition(canvas, e);
        released(canvas, e);
    });

    canvas.addEventListener("mousemove", function (e) {
        getMousePosition(canvas, e);
        moved(canvas, e);
    });
}
canvas_height = canvas_width;

canvas.width = canvas_width;
canvas.height = canvas_height;

let animate = window.requestAnimationFrame
    || window.webkitRequestAnimationFrame
    || window.mozRequestAnimationFrame
    || function (callback) {
        window.setTimeout(callback, 1000 / fps);
    };

window.onload = function () {
    initParams();
    animate(step);
}

function step() {
    update();
    render();
    animate(step);
}

function getProspectivePoint() {
    let prospective_point = -1;
    for (let i = 0; i < control_points.length; i++) {
        if (getDistance(click_x, click_y, control_points[i].x, control_points[i].y) < leeway) {
            prospective_point = i;
        }
    }
    return prospective_point;
}

function clicked() {
    let prospective_point = getProspectivePoint();

    if (!selected) {
        selected = true;
        selected_point = prospective_point;
        disableScroll();
    }
    else {
        if (prospective_point < 0) {
            selected = false;
            enableScroll();
        }
        else if (prospective_point == selected_point) {
            selected = false;
            enableScroll();
        }
        else {
            selected = true;
            selected_point = prospective_point;
            disableScroll();
        }
    }
    updateSelected();
}

function released() {
    selected = false;
    enableScroll();
    updateSelected();
}

function moved() {
    if (selected) {
        updateParams("pointer");
    }
}

function getMousePosition(canvas, event) {
    rect = canvas.getBoundingClientRect();
    click_x = event.clientX - rect.left;
    click_y = event.clientY - rect.top;
}

function getTouchPosition(canvas, event) {
    var rect = canvas.getBoundingClientRect();
    click_x = event.touches[0].clientX - rect.left;
    click_y = event.touches[0].clientY - rect.top;

    if(click_x < 0) {
        click_x = 0;
    }
    else if(click_x > canvas_width) {
        click_x = canvas_width;
    }
    if(click_y < 0) {
        click_y = 0;
    }
    else if(click_y > canvas_height) {
        click_y = canvas_height;
    }
}

// Scroll disable part
// spacebar: 32, pageup: 33, pagedown: 34, end: 35, home: 36
var keys = {37: 1, 38: 1, 39: 1, 40: 1};

function preventDefault(e) {
  e.preventDefault();
}

function preventDefaultForScrollKeys(e) {
  if (keys[e.keyCode]) {
    preventDefault(e);
    return false;
  }
}

// modern Chrome requires { passive: false } when adding event
var supportsPassive = false;
try {
  window.addEventListener("test", null, Object.defineProperty({}, 'passive', {
    get: function () { supportsPassive = true; } 
  }));
} catch(e) {}

var wheelOpt = supportsPassive ? { passive: false } : false;
var wheelEvent = 'onwheel' in document.createElement('div') ? 'wheel' : 'mousewheel';

function disableScroll() {
    window.addEventListener('DOMMouseScroll', preventDefault, false); // older FF
    window.addEventListener(wheelEvent, preventDefault, wheelOpt); // modern desktop
    window.addEventListener('touchmove', preventDefault, wheelOpt); // mobile
    window.addEventListener('keydown', preventDefaultForScrollKeys, false);
  }
  
  // call this to Enable
  function enableScroll() {
    window.removeEventListener('DOMMouseScroll', preventDefault, false);
    window.removeEventListener(wheelEvent, preventDefault, wheelOpt); 
    window.removeEventListener('touchmove', preventDefault, wheelOpt);
    window.removeEventListener('keydown', preventDefaultForScrollKeys, false);
  }



================================================
FILE: bezier_curves/bezier_curves.js
================================================
let control_points = [];
let render_points = [];
let selected_point;

let num_default, num_points;

let point_radius, prec, num_inter;

let click_x, click_y;
let selected;
let leeway;

// states
let interpolated;

function update() {
    if (!interpolated) {
        render_points = [];

        if (num_points > 1) {
            let old_points = [], new_points = [];

            for (let i = 0; i < 1; i += prec) {
                old_points = control_points;

                for (let level = old_points.length - 1; level > 0; level--) {
                    new_points = [];
                    for (let index = 1; index < old_points.length; index++) {
                        new_points.push({
                            x: (1 - i) * old_points[index - 1].x + i * old_points[index].x,
                            y: (1 - i) * old_points[index - 1].y + i * old_points[index].y
                        });
                    }
                    old_points = new_points;
                }

                render_points.push({
                    x: new_points[0].x,
                    y: new_points[0].y
                });
            }
        }

        interpolated = true;
    }
}

function render() {
    context.fillStyle = "#000000";
    context.fillRect(0, 0, canvas_width, canvas_height);

    for (let point of control_points) {
        point.render();
    }

    if (num_points > 1) {
        context.strokeStyle = "#ffffff";
        context.beginPath();
        context.moveTo(render_points[0].x, render_points[0].y);
        for (let i = 1; i < render_points.length; i++) {
            context.lineTo(render_points[i].x, render_points[i].y);
        }
        context.stroke();
    }
}

function updateParams(variable) {
    if (variable == "x") {
        control_points[selected_point].x = click_x;
        interpolated = false;
    }
    if (variable == "y") {
        control_points[selected_point].y = canvas_height - y_input.value;
        interpolated = false;
    }
    if (variable == "pointer") {
        control_points[selected_point].x = click_x;
        control_points[selected_point].y = click_y;
        interpolated = false;
    }
}

function updateSelected() {
    for (let point of control_points) {
        point.selected = false;
    }
    if (selected) {
        control_points[selected_point].selected = true;
    }
}

function initParams() {
    control_points = [];
    point_radius = 6;
    num_inter = 100;
    prec = 1 / num_inter;

    interpolated = false;
    selected = false;

    if (mobile) {
        leeway = 12;
    }
    else {
        leeway = 5;
    }

    setPattern("treble");
}

function getHue(number) {
    return Math.floor(number * 255 / num_inter);
}

function addPoint() {
    if (num_points == 0) {
        control_points.push(new Point("#ff0000"));
    }
    else if (num_points == 1) {
        control_points.push(new Point("#0000ff"));
    }
    else if (num_points > 1) {
        let temp_point = control_points.pop();
        control_points.push(new Point("#00ff00"));
        control_points.push(temp_point);
    }
    num_points++;
    interpolated = false;
}

function clearPoints() {
    control_points = [];
    num_points = 0;
    interpolated = false;
}

function removePoint() {
    if(num_points > 0) {
        control_points.pop();
        if(num_points > 2) {
            control_points[control_points.length - 1].color = "#0000ff";
        }
        num_points--;
        interpolated = false;
    }
}

function printRelativeCoords() {
    for(let point of control_points) {
        console.log(`pushPoint(${(point.x/canvas_width).toFixed(4)}, ${(point.y/canvas_height).toFixed(4)})`);
    }
}


================================================
FILE: bezier_curves/patterns.js
================================================
function setPattern(pattern) {
    control_points = [];
    if (pattern == "treble") {
        pushPoint(0.5230, 0.8398)
        pushPoint(0.4601, 0.0369)
        pushPoint(0.5317, 0.0369)
        pushPoint(0.3733, 0.1128)
        pushPoint(0.7075, 0.1324)
        pushPoint(0.6619, 0.0608)
        pushPoint(0.7010, 0.2279)
        pushPoint(0.2344, 0.6619)
        pushPoint(0.2148, 0.3819)
        pushPoint(0.1888, 0.5143)
        pushPoint(0.4253, 0.9288)
        pushPoint(0.6250, 0.9288)
        pushPoint(0.7075, 0.5273)
        pushPoint(0.6771, 0.6359)
        pushPoint(0.6337, 0.3928)
        pushPoint(0.4492, 0.5404)
    }
    setColors();
    num_points = control_points.length;
}

function pushPoint(new_x, new_y) {
    let new_point = new Point("#00ff00");
    new_point.x = new_x * canvas_width;
    new_point.y = new_y * canvas_height;
    control_points.push(new_point);
}

function setColors() {
    control_points[0].color = "#ff0000";
    control_points[control_points.length - 1].color = "#0000ff";
}


================================================
FILE: bezier_curves/Point.js
================================================
class Point {
    constructor(color) {
        this.x = canvas_width / 8 + 3 * Math.random() * canvas_width / 4;
        this.y = canvas_width / 8 + 3 * Math.random() * canvas_height / 4;
        this.selected = false;
        this.color = color;
    }
    render() {
        context.fillStyle = this.color;
        context.beginPath();
        context.arc(this.x, this.y, point_radius, 0, 2 * Math.PI, false);
        context.fill();

        if(this.selected) {
            context.strokeStyle = "#ffffff";
            context.beginPath();
            context.arc(this.x, this.y, 2 * point_radius, 0, 2 * Math.PI, false);
            context.stroke();
        }
    }
}


================================================
FILE: bezier_curves/simulation.html
================================================
<!DOCTYPE html>
<html lang="en-US">

<head>
  <title>Bezier Curves | Visualize It</title>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="keywords" content="bezier, bezier curve, bezier curves, interactive, computer fonts">
  <meta name="og:image" content="https://github.com/visualize-it/visualize-it.github.io/raw/main/images_webp/bezier_curves.webp">

  <!-- Materialize -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/js/materialize.min.js"></script>
  <script src="../helper.js" defer></script>
  <script src="basic.js" defer></script>
  <script src="Point.js" defer></script>
  <script src="bezier_curves.js" defer></script>
  <script src="patterns.js" defer></script>
  <script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML">
    </script>

  <!-- CSS -->
  <link rel="stylesheet" href="../style.css" />
</head>

<script async src="https://www.googletagmanager.com/gtag/js?id=G-M95CKRP8HB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() { window.dataLayer.push(arguments); }
  gtag('js', new Date());

  gtag('config', 'G-M95CKRP8HB');
</script>

<body>
  <nav class="nav-extended" style="background:black; margin-top: 0mm">
    <div class="nav-wrapper">
      <h1 id="main-heading">Visualize It</h1>
    </div>
    <div class="nav-content">
      <ul class="tabs tabs-transparent tabs-fixed-width">
        <li class="tab"><a href="../index.html" style="font-size: larger;">Home</a></li>
        <li class="tab"><a href="../about.html" style="font-size: larger;">About</a></li>
      </ul>
    </div>
  </nav>
</body>

<div class="text">
  <h2>Bezier Curves</h2>
  <center>
    <p>
      A Bezier curve is a parametric curve used widely in designing and computer graphics. It was first used by French
      engineer Pierre Bezier in the 1960s. A bezier curve is generated through the process of recursive linear
      interpolation of control points. All text on computers are rendered as Bezier curves, since it is more efficient
      to store a bunch of coordinates than to store the coordinates of all pixels involved.
    </p>
  </center>
  <br>
  <center>
    <div class="container" style="width: 100%">
      <div class="row">
        <div class="col s12 l8">
          <canvas id="canvas"></canvas>
        </div>
        <div class="col s12 l4">
          <b>Click and drag a control point to move it</b>
          <br> <br>
          <b>On Mobiles: If unable to scroll, then touch the below canvas and try again</b>
          <br> <br>
          <button class="btn purple darken-4" onclick="addPoint()">Add</button> <br> <br>
          <button class="btn purple darken-4" onclick="clearPoints()">Clear</button> <br> <br>
          <button class="btn purple darken-4" onclick="removePoint()">Remove</button> <br> <br>
        </div>
      </div>
    </div>
  </center>

  <br>
  <hr>

  <h3>Description</h3>

  <p>
    Linear interpolation between two points \((x_1, y_1)\) and \((x_2, y_2)\) is a process of uniformly tracing the
    space between them. To be more mathematical, it involves varying a parameter, say \(t\), from 0 to 1, in the
    following equations:
    \[ x = x_1 + t (x_2 - x_1) \]
    \[ y = y_1 + t (y_2 - y_1) \]
    The line traced by the point \((x, y)\) as \(t\) varies from 0 to 1 is called a linear interpolation. At \(t = 0\),
    the line begins from \((x_1, y_1)\). At \(t = 1\), the line ends at \((x_2, y_2)\).
  </p>
  <p>
    Let us consider the case of just two points. Then linear interpolation between them will just generate a straight
    line connecting the two points. The red dot is the initial point whereas the blue dot is the final point.
  </p>
  <p>
    Now, add another point. This point fits in between the initial and final point. We consider (but won't draw) a line
    between the 1st and 2nd point, and a line between the 2nd and 3rd point. Interpolating between these two lines and
    joining the interpolated points will give us a moving line. When interpolation takes place between the two lines, we
    also interpolate the resulting line, and trace the interpolated point. This gives us a quadratic bezier curve.
  </p>
  <p>
    In general, with \(n\) points, we get \(n-1\) lines by interpolation. We interpolate between these lines to get
    \(n-2\) lines and so on. Until we arrive at only one interpolated line. Tracing it's interpolation gives us the
    corresponding Bezier curve.
  </p>
  <p>
    It might be hard to understand the working of a Bezier curve using just textual description. In this case, fret not.
    A lot of videos are available online (I would recommend <a href="https://www.youtube.com/watch?v=aVwxzDHniEw"
      target="_blank">this one</a>). This website just allows you to play with Bezier curves.
  </p>
  <br>
  <hr>

  <p class="center-align">Developed by ChanRT | Fork me at <a href="https://www.github.com/chanrt">GitHub</a></p>
</div>

</html>


================================================
FILE: clustering/basic.js
================================================
let screen_width = window.innerWidth, screen_height = window.innerHeight;
let canvas_width, canvas_height;
let fps = 24, paused = false;
let mobile;

if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
    mobile = true;
} else {
    mobile = false;
}

let canvas = document.getElementById("canvas");
let context = canvas.getContext("2d");

let num_display = document.getElementById("num-display");
let num_input = document.getElementById("num-input");
let cost_display = document.getElementById("cost-display");

if (mobile) {
    canvas_width = 0.9 * screen_width;
}
else {
    canvas_width = 0.4 * screen_width;
}
canvas_height = canvas_width;

canvas.width = canvas_width;
canvas.height = canvas_height;

let animate = window.requestAnimationFrame
    || window.webkitRequestAnimationFrame
    || window.mozRequestAnimationFrame
    || function (callback) {
        window.setTimeout(callback, 1000 / fps);
    };

function step() {
    if (!paused) {
        update();
    }
    render();
    animate(step);
}

window.onload = function() {
    initParams();
    defaultSetup();
    animate(step);
}

function defaultSetup() {
    let x1 = canvas_width / 4;
    let y1 = canvas_height / 4;
    let x2 = 3 * canvas_width / 4;
    let y2 = 3 * canvas_height / 4;
    let variance = canvas_width / 3;

    let num_points_each = 8;

    for (let i = 0; i < num_points_each; i++) {
        let x = x1 + Math.random() * variance - variance / 2;
        let y = y1 + Math.random() * variance - variance / 2;
        points.push({
            x: x,
            y: y,
            group: -1,
            color: "#ffffff",
        });
    }

    for (let i = 0; i < num_points_each; i++) {
        let x = x2 + Math.random() * variance - variance / 2;
        let y = y2 + Math.random() * variance - variance / 2;
        points.push({
            x: x,
            y: y,
            group: -1,
            color: "#ffffff",
        });
    }

    num_clusters = 2;
    num_input.value = num_clusters;
    num_display.innerHTML = `Number of Clusters: ${num_clusters}`;
    
    let num_steps = 10;
    for (let i = 0; i < num_steps; i++) {
        clusterStep();
    }
}

let click_x, click_y, pressed;

if(mobile) {
    canvas.addEventListener("touchstart", function (e) {
        getTouchPosition(canvas, e);
        let touch = e.touches[0];
        let mouseEvent = new MouseEvent("mousedown", {
            clientX: touch.clientX,
            clientY: touch.clientY
        });
        canvas.dispatchEvent(mouseEvent);
        pressed = true;
        clicked();
    }, false);

    canvas.addEventListener("touchmove", function (e) {
        getTouchPosition(canvas, e);
        let touch = e.touches[0];
        let mouseEvent = new MouseEvent("mousemove", {
            clientX: touch.clientX,
            clientY: touch.clientY
        });
        canvas.dispatchEvent(mouseEvent);
        moved();
    }, false);

    canvas.addEventListener("touchend", function (e) {
        getTouchPosition(canvas, e);
        let touch = e.touches[0];
        let mouseEvent = new MouseEvent("mouseup", {
            clientX: touch.clientX,
            clientY: touch.clientY
        });
        canvas.dispatchEvent(mouseEvent);
        pressed = false;
        released();
    }, false);
}
else {
    canvas.addEventListener("mousedown", function (e) {
        getMousePosition(canvas, e);
        pressed = true;
        clicked();
    });

    canvas.addEventListener("mousemove", function (e) {
        getMousePosition(canvas, e);
        moved();
    });

    canvas.addEventListener("mouseup", function (e) {
        getMousePosition(canvas, e);
        pressed = false;
        released();
    });

    window.addEventListener("keydown", function(e) {
        keyPressed(e.keyCode);
    }, false);

    window.addEventListener("keydown", function(e) {
        keyReleased(e.keyCode);
    }, false);
}

function getMousePosition(canvas, event) {
    rect = canvas.getBoundingClientRect();
    click_x = event.clientX - rect.left;
    click_y = event.clientY - rect.top;
}

function getTouchPosition(canvas, event) {
    var rect = canvas.getBoundingClientRect();
    click_x = event.touches[0].clientX - rect.left;
    click_y = event.touches[0].clientY - rect.top;
}


================================================
FILE: clustering/simulation.html
================================================
<!DOCTYPE html>
<html lang="en-US">

<head>
  <title>Clustering | Visualize It</title>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="keywords" content="clustering, k-means, k-means clustering, machine learning, unsupervised, interactive">
  <meta name="og:image"
    content="https://github.com/visualize-it/visualize-it.github.io/raw/main/images_webp/clustering.webp">

  <!-- Materialize -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/js/materialize.min.js"></script>

  <script src="../helper.js" defer></script>
  <script src="basic.js" defer></script>
  <script src="user_input.js" defer></script>
  <script src="simulation.js" defer></script>

  <script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML">
    </script>

  <!-- CSS -->
  <link rel="stylesheet" href="../style.css" />
</head>

<script async src="https://www.googletagmanager.com/gtag/js?id=G-M95CKRP8HB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() { window.dataLayer.push(arguments); }
  gtag('js', new Date());

  gtag('config', 'G-M95CKRP8HB');
</script>

<body>
  <nav class="nav-extended" style="background:black; margin-top: 0mm">
    <div class="nav-wrapper">
      <h1 id="main-heading">Visualize It</h1>
    </div>
    <div class="nav-content">
      <ul class="tabs tabs-transparent tabs-fixed-width">
        <li class="tab"><a href="../index.html" style="font-size: larger;">Home</a></li>
        <li class="tab"><a href="../about.html" style="font-size: larger;">About</a></li>
      </ul>
    </div>
  </nav>
</body>

<div class="text">
  <h2>Clustering</h2>
  <p>Given a set of 'n' points in space, the k-means clustering algorithm attempts to classify 'n' points into 'k'
    clusters such that the sum of distances of each point from the mean of it's respective cluster is minimized.
    Although this simulation showcases k-means clustering in 2D space, it is can be easily extended to further
    dimensions. Circles represent the points. Squares represent the (tentative) centroids of clusters. All points
    belonging to the same cluster share the same color.</p>

  <br>
  <div class="container">
    <div class="row">
      <div class="col s12 l4">
        <center>
          <canvas id="canvas"></canvas>
        </center>
      </div>
      <div class="col s12 l4 push-l4">
        <center>
          <p id="num-display"></p>
          <input type="range" id="num-input" min="2" max="6" step="1" oninput="updateParams('num')"
            onchange="updateParams('num')">
          <button class="btn purple darken-4" onclick="clusterStep()">Iterate</button>
          <button class="btn purple darken-4" onclick="resetCentroids()">Reset</button>
          <button class="btn purple darken-4" onclick="clearPoints()">Clear</button>
          <br>
          <p id="cost-display"></p>
          <br>
          <hr>
          <br>
          <p>
            Click on the screen to insert a point. Click on a point to remove it. Press 'Iterate' to progress the
            clustering process. Press 'Reset' to restart the clustering process anew. Press 'Clear' to remove all
            existing points
          </p>
        </center>
      </div>
    </div>
  </div>

  <br>
  <hr>

  <h3>Algorithm</h3>

  <p>
    Psuedocode of k-means clustering algorithm is as follows:
  <ol>
    <li>Randomly insert k centroids in the space.</li>
    <li>Assign each point to the nearest centroid. All points assigned to the same centroid form a cluster. It is
      imperative to verify that each centroid has atleast one point assigned to it. Otherwise, repeat the previous step.
    </li>
    <li>Within each cluster, compute it's centroid, and move the assigned centroid to the computed position</li>
    <li>Repeat the previous step until the cost function (sum of distances of each point from the centroid of it's
      respective cluster) stops decreasing further.</li>
  </ol>
  It is not guaranteed that the algorithm will converge to a global minimum. It might get stuck in a local minimum, in
  which case, the process must be restarted with a new set of initial centroids. The cost function quantifies how good
  the clustering is. A lower cost function signifies better clustering.
  </p>

  <br>
  <hr>
  <br>

  <b>Note:</b>
  <ol>
    <li>
      The metric used here is Euclidean distance
    </li>
    <li>
      There is a bug that occurs with 6 clusters. Two of the centroids are of same color.
    </li>
    <li>
      Related: <a href="../gradient_descent/simulation.html">Gradient Descent</a>, 
      <a href="../natural_selection/simulation.html">Genetic Algorithm</a>, 
      <a href="../polynomial_regression/simulation.html">Polynomial Regression</a>.
    </li>
  </ol>

  <br>
  <hr>

  <p class="center-align">Developed by ChanRT | Fork me at <a href="https://www.github.com/chanrt">GitHub</a></p>
</div>

</html>


================================================
FILE: clustering/simulation.js
================================================
let points = [];
let centroids = [];

let num_clusters;

let point_radius, exclusion_radius;

let initialized;

function clusterStep() {
    if (points.length > 0) {
        if (!initialized) {
            initialize();
            initialized = true;
        }
        else {
            let new_centroids = [];

            let centroid_x, centroid_y, num_points;
            for (let i = 0; i < num_clusters; i++) {
                centroid_x = 0;
                centroid_y = 0;
                num_points = 0;

                for (let point of points) {
                    if (point.group == i) {
                        centroid_x += point.x;
                        centroid_y += point.y;
                        num_points++;
                    }
                }
                centroid_x /= num_points;
                centroid_y /= num_points;

                new_centroids.push({
                    x: centroid_x,
                    y: centroid_y
                })
            }
            centroids = new_centroids;
            assignCentroids();
            
        }
    }
    calcCost();
}

function assignCentroids() {
    let min_distance, nearest_centroid_index, distance;
    for (let point of points) {
        min_distance = 2 * canvas_width;
        nearest_centroid_index = -1;

        for (let i = 0; i < centroids.length; i++) {
            distance = distanceBetweenPoints(point, centroids[i]);
            if (distance < min_distance) {
                min_distance = distance;
                nearest_centroid_index = i;
            }
        }
        point.group = nearest_centroid_index;
    }

    let unassigned_centroids = [];
    for (let i = 0; i < num_clusters; i++) {
        unassigned_centroids.push(true);
    }

    for (let point of points) {
        unassigned_centroids[point.group] = false;
    }

    for (let i = 0; i < num_clusters; i++) {
        if(unassigned_centroids[i] == true) {
            return false;
        }
    }

    assignColors();
    console.log(points);
    console.log(centroids);

    return true;
}

function calcCost() {
    let cost = 0;
    for (let point of points) {
        cost += distanceBetweenPoints(point, centroids[point.group]);
    }
    cost_display.innerHTML = `Current cost: ${cost.toFixed(2)}`
}

function initialize() {
    let x, y;

    while (true) {
        centroids = [];
        for (let i = 0; i < num_clusters; i++) {
            x = Math.random() * canvas_width;
            y = Math.random() * canvas_height;
            centroids.push({
                x: x,
                y: y
            })
        }
        if (assignCentroids()) {
            break;
        }
    }
    
}

function update() {

}

function render() {
    context.fillStyle = "#000000";
    context.fillRect(0, 0, canvas_width, canvas_height);

    for (let point of points) {
        context.fillStyle = point.color;
        context.beginPath();
        context.arc(point.x, point.y, point_radius, 0, 2 * Math.PI, false);
        context.fill();
    }

    for (let centroid of centroids) {
        context.fillStyle = centroid.color;
        context.beginPath();
        context.moveTo(centroid.x - point_radius, centroid.y - point_radius);
        context.lineTo(centroid.x + point_radius, centroid.y - point_radius);
        context.lineTo(centroid.x + point_radius, centroid.y + point_radius);
        context.lineTo(centroid.x - point_radius, centroid.y + point_radius);
        context.lineTo(centroid.x - point_radius, centroid.y - point_radius);
        context.fill();
    }

    if (centroids.length > 0) {
        for (let i = 0; i < num_clusters; i++) {
            context.strokeStyle = centroids[i].color;
            for (let point of points) {
                if (point.group == i) {
                    context.beginPath();
                    context.moveTo(point.x, point.y);
                    context.lineTo(centroids[i].x, centroids[i].y)
                    context.stroke();
                }
            }
        }
    }
}

function updateParams(variable) {
    if (variable == "num") {
        num_clusters = num_input.value;
        num_display.innerHTML = `Number of Clusters: ${num_clusters}`;
        resetCentroids();
    }
}

function initParams() {
    initialized = false;

    if (mobile) {
        point_radius = 5;
    }
    else {
        point_radius = 8;
    }
    exclusion_radius = point_radius;

    num_input.value = 2;
    updateParams('num')
}

function assignColors() {
    for (let i = 0; i < num_clusters; i++) {
        centroids[i].color = getColor(i);
    }

    for (let point of points) {
        point.color = getColor(point.group);
    }
}

function getColor(group) {
    switch (group) {
        case 0:
            return "#ff0000";
        case 1:
            return "#00ff00";
        case 2:
            return "#0000ff";
        case 3:
            return "#ffa500";
        case 4:
            return "#aaaaaa";
        case 5:
            return "#ffcocb"
    }
}

function addPoint() {
    let point_removed;
    for (let point of points) {
        if (distanceBetweenCoordAndPoint(click_x, click_y, point) < exclusion_radius) {
            points = removeElement(points, point);
            point_removed = true;
            break;
        }
    }

    if (!point_removed) {
        points.push({
            x: click_x,
            y: click_y,
            group: -1,
            color: "#ffffff"
        });
    }
    initialized = false;
}

function clearPoints() {
    points = [];
    centroids = [];
    initialized = false;

    calcCost();
}

function resetCentroids() {
    centroids = [];
    for (let point of points) {
        point.group = -1;
        point.color = "#ffffff";
    }
    initialized = false;

    calcCost();
}

function distanceBetweenPoints(point1, point2) {
    return Math.sqrt(Math.pow(point2.x - point1.x, 2) + Math.pow(point2.y - point1.y, 2));
}

function distanceBetweenCoordAndPoint(x, y, point) {
    return Math.sqrt(Math.pow(point.x - x, 2) + Math.pow(point.y - y, 2));
}


================================================
FILE: clustering/user_input.js
================================================
function clicked() {
    addPoint();
}

function moved() {

}

function released() {

}

function keyPressed(key) {

}

function keyReleased(key) {
    
}


================================================
FILE: collatz_conjecture/basic.js
================================================
let screen_width = window.innerWidth, screen_height = window.innerHeight;
let fps = 24;

let canvas = document.getElementById("canvas");
let context = canvas.getContext("2d");

let max_value_display = document.getElementById("max-value-display");
let stoptime_display = document.getElementById("stoptime-display");
let number_input = document.getElementById("number-input");

if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
    mobile = true;
} else {
    mobile = false;
}

if (mobile) {
    canvas_width = 0.9 * screen_width;
}
else {
    canvas_width = 0.5 * screen_width;
}
canvas_height = canvas_width / 1.62;

canvas.width = canvas_width;
canvas.height = canvas_height;

let animate = window.requestAnimationFrame
    || window.webkitRequestAnimationFrame
    || window.mozRequestAnimationFrame
    || function (callback) {
        window.setTimeout(callback, 1000 / fps);
    };

window.onload = function () {
    initParams();
    animate(step);
}

function step() {
    update();
    render();
    animate(step);
}


================================================
FILE: collatz_conjecture/collatz_conjecture.js
================================================
let series = [];
let starting_number, current_number;
let speed, max_value;

// states
let completed;

function update() {
    for (let iteration = 0; iteration < speed && current_number != 1; iteration++, stopping_time++) {
        if (current_number % 2 == 0) {
            current_number /= 2;
        }
        else {
            current_number = 3 * current_number + 1;
        }
        series.push(current_number);
    }
    
    if(current_number == 1) {
        completed = true;
        max_value = getMax();

        max_value_display.innerHTML = `Maximum value attained: ${max_value}`;
        stoptime_display.innerHTML = `Stopping time: ${stopping_time}`; 
    }
}

function render() {
    if (!completed) {
        context.fillStyle = "#000000";
        context.fillRect(0, 0, canvas_width, canvas_height);

        let x_scale = canvas_width / series.length;
        let y_scale = canvas_height / getMax();

        context.strokeStyle = "#ffffff";
        context.beginPath();
        context.moveTo(0, canvas_height - series[0] * y_scale);
        for (let i = 1; i < series.length; i++) {
            context.lineTo(i * x_scale, canvas_height - series[i] * y_scale);
        }
        context.stroke();
    }
}

function updateParams(variable) {

}

function iterate() {
    current_number = number_input.value;
    stopping_time = 0;
    speed = Math.floor(Math.log(current_number));
    series = [starting_number];
    completed = false;
}

function initParams() {
    number_input.value = 27;
    iterate();
}

function getMax() {
    let max = 0;
    for (let number of series) {
        if (number > max) {
            max = number;
        }
    }
    return max;
}


================================================
FILE: collatz_conjecture/simulation.html
================================================
<!DOCTYPE html>
<html lang="en-US">

<head>
    <title>Collatz Conjecture | Visualize It</title>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- Materialize -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/js/materialize.min.js"></script>
    <script src="basic.js" defer></script>
    <script src="collatz_conjecture.js" defer></script>
    <script type="text/javascript" async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML">
        </script>

    <!-- CSS -->
    <link rel="stylesheet" href="../style.css" />
</head>

<script async src="https://www.googletagmanager.com/gtag/js?id=G-M95CKRP8HB"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { window.dataLayer.push(arguments); }
    gtag('js', new Date());

    gtag('config', 'G-M95CKRP8HB');
</script>

<body>
    <nav class="nav-extended" style="background:black; margin-top: 0mm">
        <div class="nav-wrapper">
            <h1 id="main-heading">Visualize It</h1>
        </div>
        <div class="nav-content">
            <ul class="tabs tabs-transparent tabs-fixed-width">
                <li class="tab"><a href="../index.html">Home</a></li>
                <li class="tab"><a href="../about.html">About</a></li>
            </ul>
        </div>
    </nav>

    <div class="text">
        <h2>Collatz Conjecture</h2>
        <p>
            The Collatz problem is one of those unsolved problems in mathematics which can be understood (ironically) by
            common people. Beginning with any positive integer x<sub>1</sub> = k, we successively iterate using
            x<sub>n</sub> = x<sub>n-1</sub> / 2 if x<sub>n-1</sub> is even, or x<sub>n</sub> = 3 * x<sub>n-1</sub> + 1
            otherwise. Collatz conjecture claims that x<sub>n</sub> eventually reaches '1' for every positive integer k
            that we begin with. The following graph portrays the behaviour of the input number when subjected to the
            aforementioned iterations. Stopping time is the number of iterations after which we obtain '1'.
        </p>
        <br>
        <div class="container" style="width:90%;">
            <div class="row">
                <div class="col s12 l8">
                    <center>
                        <b>X-axis: iterations; Y-axis: number</b>
                    </center>
                    <canvas id="canvas"></canvas>
                </div>
                <div class="col s12 l4">
                    <center>
                        <p id="max-value-display"></p>
                        <p id="stoptime-display"></p>
                        <input type="number" id="number-input" style="max-width: 300px;" placeholder="Enter number">
                        <br>
                        <button class="btn purple darken-4" onclick="iterate()">Iterate</button>
                    </center>
                </div>
            </div>
        </div>

        <br>
        <hr>

        <h3 class="center">Brief Description</h3>

        <p>
            Despite the apparent simplicity of the conjecture, no one has been able to prove it. It has been found
            correct for number until 300 quintillion, via brute-force computation). However, that is hardly a proof.
            There are two circumstances under which this conjecture is false: 1) If there is a number that never
            converges to 1 or 2) If the number go about in an infinitely repeating loop. There are a lot of proofs which
            convey that this conjecture is true for <em>almost</em> all numbers. or that <em>most</em> numbers, on
            average, decrease during iterations. A conclusive proof is at large.
        </p>

        <br>
        <hr>
        <br>

        <b>Note:</b>

        <ol>
            <li>Obtain interesting data about stopping times from <a
                    href="https://en.wikipedia.org/wiki/Collatz_conjecture#Empirical_data" target="_blank">here</a>.
            </li>
            <li>Some numbers undergo a lot of iterations before reaching 1. In such cases, the graph may look
                horizontally compressed if your device is low-width.</li>
            <li>Some numbers iterate through a large range of values. The maximum value attained is displayed at the
                end. If this value is high, then small changes go unnoticed.</li>
        </ol>

        <br>
        <hr>

        <p class="center-align">Developed by ChanRT | Fork me at <a href="https://www.github.com/chanrt">GitHub</a></p>
    </div>
</body>

</html>


================================================
FILE: collective_behaviour/basic.js
================================================
let screen_width = window.innerWidth, screen_height = window.innerHeight;
let canvas_width, canvas_height;
let fps = 24, paused = false;
let mobile;

if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
    mobile = true;
} else {
    mobile = false;
}

let canvas = document.getElementById("canvas");
let context = canvas.getContext("2d");

let polar_display = document.getElementById("polar-display");
let ang_display = document.getElementById("ang-display");

let num_display = document.getElementById("num-display")

let repulsion_display = document.getElementById("repulsion-display");
let repulsion_input = document.getElementById("repulsion-input");

let orientation_display = document.getElementById("orientation-display");
let orientation_input = document.getElementById("orientation-input");

let attraction_display = document.getElementById("attraction-display");
let attraction_input = document.getElementById("attraction-input");

let moving_speed_display = document.getElementById("moving-speed-display");
let moving_speed_input = document.getElementById("moving-speed-input");

let turning_speed_display = document.getElementById("turning-speed-display");
let turning_speed_input = document.getElementById("turning-speed-input");

let noise_display = document.getElementById("noise-display");
let noise_input = document.getElementById("noise-input");

let blind_display = document.getElementById("blind-display");
let blind_input = document.getElementById("blind-input");

let reflect_button = document.getElementById("reflect-button");
let pause_button = document.getElementById("pause-button");

if (mobile) {
    canvas_width = 0.9 * screen_width;
}
else {
    canvas_width = 0.45 * screen_width;
}
canvas_height = canvas_width;

canvas.width = canvas_width;
canvas.height = canvas_height;

let animate = window.requestAnimationFrame
    || window.webkitRequestAnimationFrame
    || window.mozRequestAnimationFrame
    || function (callback) {
        window.setTimeout(callback, 1000 / fps);
    };

function step() {
    if (!paused) {
        update();
    }
    render();
    animate(step);
}

window.onload = function () {
    defaultParams();
    initParams();
    animate(step);
}

function defaultParams() {
    if (mobile) {
        spoke_length = 5;
        characteristic_length = 8;
    }
    else {
        spoke_length = 8;
        characteristic_length = 12;
    }

    repulsion_input.value = 1;
    orientation_input.value = 3;
    attraction_input.value = 15;

    moving_speed_input.value = 7;
    turning_speed_input.value = 8;
    noise_input.value = 10;

    blind_input.value = 90;
    reflect = false;

    if (reflect == false) {
        reflect_button.innerHTML = "Reflect: Off";
    }
    else {
        reflect_button.innerHTML = "Reflect: On";
    }
}

let click_x, click_y, pressed;

if(mobile) {
    canvas.addEventListener("touchstart", function (e) {
        getTouchPosition(canvas, e);
        let touch = e.touches[0];
        let mouseEvent = new MouseEvent("mousedown", {
            clientX: touch.clientX,
            clientY: touch.clientY
        });
        canvas.dispatchEvent(mouseEvent);
        pressed = true;
        clicked();
    }, false);

    canvas.addEventListener("touchmove", function (e) {
        getTouchPosition(canvas, e);
        let touch = e.touches[0];
        let mouseEvent = new MouseEvent("mousemove", {
            clientX: touch.clientX,
            clientY: touch.clientY
        });
        canvas.dispatchEvent(mouseEvent);
        moved();
    }, false);

    canvas.addEventListener("touchend", function (e) {
        getTouchPosition(canvas, e);
        let touch = e.touches[0];
        let mouseEvent = new MouseEvent("mouseup", {
            clientX: touch.clientX,
            clientY: touch.clientY
        });
        canvas.dispatchEvent(mouseEvent);
        pressed = false;
        released();
    }, false);
}
else {
    canvas.addEventListener("mousedown", function (e) {
        getMousePosition(canvas, e);
        pressed = true;
        clicked();
    });

    canvas.addEventListener("mousemove", function (e) {
        getMousePosition(canvas, e);
        moved();
    });

    canvas.addEventListener("mouseup", function (e) {
        getMousePosition(canvas, e);
        pressed = false;
        released();
    });

    window.addEventListener("keydown", function(e) {
        keyPressed(e.keyCode);
    }, false);

    window.addEventListener("keydown", function(e) {
        keyReleased(e.keyCode);
    }, false);
}

function getMousePosition(canvas, event) {
    rect = canvas.getBoundingClientRect();
    click_x = event.clientX - rect.left;
    click_y = event.clientY - rect.top;
}

function getTouchPosition(canvas, event) {
    var rect = canvas.getBoundingClientRect();
    click_x = event.touches[0].clientX - rect.left;
    click_y = event.touches[0].clientY - rect.top;
}

function pauseToggle() {
    if (paused) {
        paused = false;
        pause_button.innerHTML = "Pause";
    }
    else {
        paused = true;
        pause_button.innerHTML = "Resume";
    }
}

function toggleReflection() {
    if (reflect) {
        reflect = false;
        reflect_button.innerHTML = "Reflect: Off";
    }
    else {
        reflect = true;
        reflect_button.innerHTML = "Reflect: On";
    }
}


================================================
FILE: collective_behaviour/Boid.js
================================================
class Boid {
    constructor(position, velocity) {
        this.position = position;
        this.velocity = velocity;
        this.direction = this.velocity.getHeading();
    }

    setVelocity(required_velocity) {
        let required_direction = required_velocity.getHeading();

        // console.log(toDegree(required_direction), toDegree(this.direction));

        if (Math.abs(required_direction - this.direction) < turning_speed) {
            this.direction = required_direction;
        }
        else {
            if (required_direction < this.direction) {
                if (Math.abs(required_direction - this.direction) < Math.PI) {
                    this.direction -= turning_speed;
                }
                else {
                    this.direction += turning_speed;
                }
            }
            else {
                if (Math.abs(required_direction - this.direction) < Math.PI) {
                    this.direction += turning_speed;
                }
                else {
                    this.direction -= turning_speed;
                }
            }
        }

        this.velocity = Vector.fromHeading(this.direction);
    }

    update() {
        // update position
        let perturbation_direction = this.direction + 2 * noise_angle * (Math.random() - 0.5);
        let perturbed_velocity = Vector.fromHeading(perturbation_direction);

        this.position.x += moving_speed * perturbed_velocity.x;
        this.position.y += moving_speed * perturbed_velocity.y;

        // check bounds
        if (reflect) {
            if (this.position.x < 0) {
                this.position.x = 0;
                this.velocity.x *= -1;
                this.direction = this.velocity.getHeading();
            }
            else if (this.position.x > canvas_width) {
                this.position.x = canvas_width;
                this.velocity.x *= -1;
                this.direction = this.velocity.getHeading();
            }
            if (this.position.y < 0) {
                this.position.y = 0;
                this.velocity.y *= -1;
                this.direction = this.velocity.getHeading();
            }
            else if (this.position.y > canvas_height) {
                this.position.y = canvas_height;
                this.velocity.y *= -1;
                this.direction = this.velocity.getHeading();
            }
        }
        else {
            if (this.position.x < 0) {
                this.position.x = canvas_width;
            }
            else if (this.position.x > canvas_width) {
                this.position.x = 0;
            }
            if (this.position.y < 0) {
                this.position.y = canvas_height;
            }
            else if (this.position.y > canvas_height) {
                this.position.y = 0;
            }
        }

        this.constrain_direction();
    }

    constrain_direction() {
        while (this.direction < -Math.PI) {
            this.direction += 2 * Math.PI;
        }
        while (this.direction > Math.PI) {
            this.direction -= 2 * Math.PI;
        }
    }

    render() {
        context.fillStyle = "#ffffff";
        context.beginPath();
        context.moveTo(this.position.x + spoke_length * Math.cos(this.direction), this.position.y + spoke_length * Math.sin(this.direction));
        context.lineTo(this.position.x + spoke_length * Math.cos(this.direction + spoke_angle), this.position.y + spoke_length * Math.sin(this.direction + spoke_angle));
        context.lineTo(this.position.x + spoke_length * Math.cos(this.direction - spoke_angle), this.position.y + spoke_length * Math.sin(this.direction - spoke_angle));
        context.lineTo(this.position.x + spoke_length * Math.cos(this.direction), this.position.y + spoke_length * Math.sin(this.direction));
        context.fill();
    }
}


================================================
FILE: collective_behaviour/predefs.js
================================================
function swarm() {
    num_boids = 100;

    repulsion_input.value = 1;
    orientation_input.value = 1;
    attraction_input.value = 15;

    moving_speed_input.value = 3;
    turning_speed_input.value = 8;
    noise_input.value = 10;

    blind_input.value = 90;
    reflect = false;

    if (reflect == false) {
        reflect_button.innerHTML = "Reflect: Off";
    }
    else {
        reflect_button.innerHTML = "Reflect: On";
    }

    initParams();
    window.scrollTo(0, 300);
}

function swirl() {
    num_boids = 100;

    repulsion_input.value = 1;
    orientation_input.value = 3;
    attraction_input.value = 15;

    if (mobile) {
        moving_speed_input.value = 5;
    }
    else {
        moving_speed_input.value = 7;
    }
    turning_speed_input.value = 8;
    noise_input.value = 10;

    blind_input.value = 90;
    reflect = false;

    if (reflect == false) {
        reflect_button.innerHTML = "Reflect: Off";
    }
    else {
        reflect_button.innerHTML = "Reflect: On";
    }

    initParams();
    window.scrollTo(0, 300);
}

function dynamicParallel() {
    num_boids = 100;

    repulsion_input.value = 1;
    orientation_input.value = 6;
    attraction_input.value = 7;

    moving_speed_input.value = 3;
    turning_speed_input.value = 4;
    noise_input.value = 10;

    blind_input.value = 90;
    reflect = false;

    if (reflect == false) {
        reflect_button.innerHTML = "Reflect: Off";
    }
    else {
        reflect_button.innerHTML = "Reflect: On";
    }

    initParams();
    window.scrollTo(0, 300);
}

function highlyParallel() {
    num_boids = 100;

    repulsion_input.value = 1;
    orientation_input.value = 12;
    attraction_input.value = 15;

    moving_speed_input.value = 3;
    turning_speed_input.value = 4;
    noise_input.value = 2;

    blind_input.value = 90;
    reflect = false;

    if (reflect == false) {
        reflect_button.innerHTML = "Reflect: Off";
    }
    else {
        reflect_button.innerHTML = "Reflect: On";
    }

    initParams();
    window.scrollTo(0, 300);
}


================================================
FILE: collective_behaviour/simulation.html
================================================
<!DOCTYPE html>
<html lang="en-US">

<head>
  <title>Collective Behaviour | Visualize It</title>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="keyword"
    content="collective behaviour, flocking behaviour, interactive, boids, boids simulation, couzin model">
  <meta name="og:image"
    content="https://github.com/visualize-it/visualize-it.github.io/raw/main/images_webp/collective_behaviour.webp">

  <!-- Materialize -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/js/materialize.min.js"></script>

  <script src="utils.js" defer></script>
  <script src="basic.js" defer></script>
  <script src="user_input.js" defer></script>
  <script src="Vector.js" defer></script>
  <script src="Boid.js" defer></script>
  <script src="tests.js" defer></script>
  <script src="predefs.js" defer></script>
  <script src="simulation.js" defer></script>


  <script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML">
    </script>

  <!-- CSS -->
  <link rel="stylesheet" href="../style.css" />
</head>

<script async src="https://www.googletagmanager.com/gtag/js?id=G-M95CKRP8HB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() { window.dataLayer.push(arguments); }
  gtag('js', new Date());

  gtag('config', 'G-M95CKRP8HB');
</script>

<body>
  <nav class="nav-extended" style="background:black; margin-top: 0mm">
    <div class="nav-wrapper">
      <h1 id="main-heading">Visualize It</h1>
    </div>
    <div class="nav-content">
      <ul class="tabs tabs-transparent tabs-fixed-width">
        <li class="tab"><a href="../index.html" style="font-size: larger;">Home</a></li>
        <li class="tab"><a href="../about.html" style="font-size: larger;">About</a></li>
      </ul>
    </div>
  </nav>
</body>

<div class="text">
  <h2>Collective Behaviour</h2>

  <center>
    <p>Basic interactions like repulsion, orientation and attraction can operate to different extents and give rise to a
      variety of dynamical behaviours.</p>
  </center>

  <div class="container" style="width: 90%">
    <div style="background:black; padding: 15px; border: 2px red solid;">
      <center>
        <b>This real-time simulation is computationally complex and may induce unresponsiveness
          on lower-end devices</b>
      </center>
    </div>
    <br>

    <div class="row">
      <div class="col s12 l7">
        <canvas id="canvas"></canvas>
        <br>
      </div>
      <div class="col s12 l5">
        <center>
          <span class="jittery" id="polar-display"></span> <br>
          <span class="jittery" id="ang-display">Group angular momentum: </span>
          <hr>
          <p id="num-display"></p>
          <button class="btn purple darken-4" onclick="addBoids()">Add</button>
          <button class="btn purple darken-4" onclick="removeBoids()">Remove</button>
          <button class="btn purple darken-4" onclick="clearBoids()">Clear</button>
          <hr>
          <div class="col s12 l6">
            <span id="repulsion-display"></span>
            <input id="repulsion-input" type="range" min="0.5" max="5" step="0.1" oninput="updateParams('repulsion')"
              onchange="updateParams('repulsion')">

            <span id="orientation-display"></span>
            <input id="orientation-input" type="range" min="1" max="15" step="0.2" oninput="updateParams('orientation')"
              onchange="updateParams('orientation')">

            <span id="attraction-display"></span>
            <input id="attraction-input" type="range" min="1" max="15" step="0.2" oninput="updateParams('attraction')"
              onchange="updateParams('attraction')">
          </div>
          <div class="col s12 l6">
            <span id="moving-speed-display"></span>
            <input id="moving-speed-input" type="range" min="1" max="10" step="0.2"
              oninput="updateParams('moving-speed')" onchange="updateParams('moving-speed')">

            <span id="turning-speed-display"></span>
            <input id="turning-speed-input" type="range" min="0" max="20" step="1"
              oninput="updateParams('turning-speed')" onchange="updateParams('turning-speed')">

            <span id="noise-display"></span>
            <input id="noise-input" type="range" min="0" max="20" step="1" oninput="updateParams('noise')"
              onchange="updateParams('noise')">
          </div>

          <hr>

          <div class="col s12 l6">
            <span id="blind-display"></span>
            <input id="blind-input" type="range" min="0" max="270" step="10" oninput="updateParams('blind')"
              onchange="updateParams('blind')">
          </div>

          <div class="col s12 l6">
            <button id="reflect-button" class="btn purple darken-4" onclick="toggleReflection()"
              style="margin-top: 20px;">Reflection: On</button>
          </div>

          <hr>

          <button id="pause-button" onclick="pauseToggle()" class="btn purple darken-4">Pause</button>
          <button onclick="initParams()" class="btn purple darken-4">Restart</button>

        </center>
      </div>
    </div>
  </div>

  <hr>

  <h3>Interactions</h3>

  <p>All boids (a generic term used to indicate agents in collective behaviour) interact with each other via three
    interactions:</p>

  <ol>
    <li>
      <b>Repulsion:</b> <br>
      When boids come too close, they move away from each other. Suppose there are \(n_r\) boids within the repulsion
      radius of a particular boid \(i\). If \(\vec{d}\) represents their direction, and
      \(\vec{c}\) represents their position, then repulsion dictates:
      \[ \vec{d}_{i, r} (t + \tau) = - \sum_{j \not = i}^{n_r} \frac{\vec{c}_j (t) - \vec{c}_i (t)}{|\vec{c}_j (t) -
      \vec{c}_i (t)|} \]
    </li>
    <li>
      <b>Orientation:</b> <br>
      Boids tend to orient themselves along the direction of their neighbours. Suppose there are \(n_o\) boids within
      the orientation radius of a particular boid \(i\). If \(\vec{v}\) represents their velocity, then orientation
      dictates:
      \[ \vec{d}_{i, o} (t + \tau) = \sum_{j = 1}^{n_o} \frac{\vec{v_j} (t)}{|\vec{v_j} (t) |}\]
    </li>
    <li>
      <b>Attraction:</b> <br>
      Boids tend to move towards the centre of mass of their neighbours. Suppose there are \(n_a\) boids within the
      attraction radius of a particular boid \(i\). then attraction operates exactly opposite to orientation:
      \[ \vec{d}_{i, a} (t + \tau) = \sum_{j = 1}^{n_r} \frac{\vec{c}_j (t) - \vec{c}_i (t)}{|\vec{c}_j (t) -
      \vec{c}_i (t)|} \]
    </li>
  </ol>

  <p>
    If there are any boids in the repulsion zone of a boid, then the boid only follows the repulsion rule. If there are
    boids that lie in the attraction as well as the orientation zone, then the boid averages the result of both
    interactions. The boids can turn only at a limited angle \( \theta \) in every time step. Further, there is a blind
    angle \( \alpha \) behind each boid where it cannot perceive other boids. Every boid moves with the same velocity
    \(v\) along its current direction. The intended direction of every boid is perturbed by random noise. This
    represents errors in judgement made by the boids.
  </p>

  <hr>

  <h3>Metrics</h3>

  <p>
    The following quantities can be used to quantify the collective motion of boids:
  </p>

  <ol>
    <li>
      <b>Group polarization:</b> <br>
      This quantifies the degree of overall alignment of the boids. If every boid is moving along the same direction,
      then group polarization is 1. If all boids are moving along random directions, then group polarization is 0.
      \[ p (t) = \frac{1}{N} \left| \sum_{i}^{N} \vec{v}_i (t) \right| \]
    </li>
    <li>
      <b>Group angular momentum:</b> <br>
      Measures the degree of rotation of the group along their center:
      \[ m (t) = \frac{1}{N} \left| \sum_{i}^{N} \vec{r}_{ic} (t) \times \vec{v}_i (t) \right| \]
      Here, \( \vec{r}_{ic} = \vec{c}_i - \vec{c}_{group} \) is the displacement vector of the \(i^{th}\) boid from the
      center of mass of the group, which is given by:
      \[ \vec{c}_{group} (t) = \sum_{i = 1}^{N} \vec{c}_{i} (t) \]
    </li>
  </ol>

  <hr>

  <h3>Dynamical Behaviours</h3>

  <p>
    Depending on the strengths of various interactions, as well as other parameters, the boids can exhibit four
    different kinds of dynamical behaviour:
  </p>

  <ol>
    <li>
      <b>Swarming:</b> <br>
      Characterised by low polarization and low angular momentum <br>
      This behaviour is seen when attraction is the dominant force, and there is negligible orientation. Boids rotate in
      random directions, repeatedly flying into the center of the group and then emerging out. This sort of
      behaviour is often seen in insects.
      <br> <br>
      <center>
        <button class="btn purple darken-4" onclick="swarm()">Observe</button>
      </center>
    </li>
    <br>
    <li>
      <b>Swirling:</b> <br>
      Characterised by low polarization and high angular momentum <br>
      This behaviour is observed when orientation is low whereas attraction is relatively high. Boids
      revolve around a common point in the same direction. This behaviour is seen in fish. <br>
      <b>It may take some time for swirls to emerge</b>.
      <br> <br>
      <center>
        <button class="btn purple darken-4" onclick="swirl()">Observe</button>
      </center>
    </li>
    <br>
    <li>
      <b>Dynamic parallel grouping:</b> <br>
      Characterised by high polarisation and low angular momentum <br>
      This behaviour is observed when orientation is intermediate whereas attraction can be either intermediate or
      relatively high. Boids move in groups called 'flocks'. Seen in birds and fish.
      <br> <br>
      <center>
        <button class="btn purple darken-4" onclick="dynamicParallel()">Observe</button>
      </center>
    </li>
    <br>
    <li>
      <b>Highly parallel grouping:</b> <br>
      Characterised by very high polarisation and low angular momentum <br>
      This behaviour is seen when orientation is high. <br>
      <b>It may take some time for highly parallel groupings to emerge</b>.
      <br> <br>
      <center>
        <button class="btn purple darken-4" onclick="highlyParallel()">Observe</button>
      </center>
    </li>
  </ol>


  <br>
  <hr>
  <br>

  <b>Note:</b>

  <ol>
    <li>
      This model is from the paper "Collective Memory and Spatial Sorting in Animal Groups" by Couzin et al. <a
        href="https://doi.org/10.1006/jtbi.2002.3065">https://doi.org/10.1006/jtbi.2002.3065</a>
    </li>
    <li>
      If reflect is off, boids just teleport from one edge to another. Implementing a periodic boundary condition was
      not possible owing to the complex nature of this simulation
    </li>
    <li>
      Although this simulation is usable on a mobile, it is preferably viewed on a desktop.
    </li>
    <li>
      Related: <a href="../firefly_synchronization/simulation.html">Firefly Synchronization</a>,
      <a href="../vicsek_model/simulation.html">Vicsek Model</a>, <a
        href="../pedestrian_dynamics/simulation.html">Pedestrian Dynamics</a>.
    </li>
  </ol>

  <hr>

  <p class="center-align">Developed by ChanRT | Fork me at <a href="https://www.github.com/chanrt">GitHub</a></p>
</div>

</html>


================================================
FILE: collective_behaviour/simulation.js
================================================
// objects
let boids = [];
let num_boids = 100;

// speeds
let moving_speed = 3;
let turning_speed = 8;

// lengths
let characteristic_length;
let repulsion_radius, orientation_radius, attraction_radius;

// angles
let blind_angle;
let half_visible_angle = Math.PI - blind_angle / 2;
let noise_angle;

// states
let reflect;

// misc
let boid_step = 5;

// cosmetic
let spoke_length;
let spoke_angle = toRadian(150);

function update() {
    for (let boid of boids) {
        let repelling_boids = getBoidsWithin(boid, repulsion_radius * characteristic_length);

        if (repelling_boids.length > 0) {
            // repulsion
            let repelling_vector_sum = new Vector(0, 0);

            for (let repelling_boid of repelling_boids) {
                let repelling_vector = Vector.subtract(repelling_boid.position, boid.position);
                repelling_vector_sum.add(Vector.normalize(repelling_vector));
            }

            repelling_vector_sum.negate();
            repelling_vector_sum.normalize();

            boid.setVelocity(repelling_vector_sum);
        }
        else {
            let orienting_boids = getBoidsWithin(boid, orientation_radius * characteristic_length);
            let attracting_boids = getBoidsWithin(boid, attraction_radius * characteristic_length);

            // orientation
            let orienting_vector_sum = new Vector(0, 0);
            for (let orienting_boid of orienting_boids) {
                let orienting_vector = orienting_boid.velocity;
                orienting_vector_sum.add(orienting_vector);
            }
            orienting_vector_sum.normalize();

            // attraction
            let attracting_vector_sum = new Vector(0, 0);
            for (let attracting_boid of attracting_boids) {
                let attracting_vector = Vector.subtract(attracting_boid.position, boid.position);
                attracting_vector_sum.add(Vector.normalize(attracting_vector));
            }
            attracting_vector_sum.normalize();

            if (orienting_boids.length > 0 && attracting_boids.length == 0) {
                boid.setVelocity(orienting_vector_sum);
            }
            else if (attracting_boids.length > 0 && orienting_boids.length == 0) {
                boid.setVelocity(attracting_vector_sum);
            }
            else if (orienting_boids.length > 0 && attracting_boids.length > 0) {
                orienting_vector_sum.scale(0.5);
                attracting_vector_sum.scale(0.5);
                let required_velocity = Vector.add(orienting_vector_sum, attracting_vector_sum);
                required_velocity.normalize();
                boid.setVelocity(required_velocity);
            }
        }
    }

    let polarization_sum = new Vector(0, 0);
    for (let boid of boids) {
        polarization_sum.add(boid.velocity);
    }
    let group_polarization = polarization_sum.magnitude() / num_boids;
    polar_display.innerHTML = `Group polarization: ${group_polarization.toFixed(2)}`;

    let position_sum = new Vector(0, 0);
    for (let boid of boids) {
        position_sum.add(boid.position);
    }
    let center_of_mass = new Vector(position_sum.x / num_boids, position_sum.y / num_boids);

    let cross_product = 0;
    for (let boid of boids) {
        cross_product += Vector.cross(Vector.subtract(boid.position, center_of_mass), boid.velocity);
    }
    let group_angular_momentum = Math.abs(cross_product) / num_boids;
    ang_display.innerHTML = `Group angular momentum: ${group_angular_momentum.toFixed(2)}`;

    for (let boid of boids) {
        boid.update();
    }
}

function render() {
    context.fillStyle = "#000000";
    context.fillRect(0, 0, canvas_width, canvas_height);

    for (let boid of boids) {
        boid.render();
    }
}

function updateParams(variable) {
    if (variable == "num-boids") {
        num_display.innerHTML = `Number of boids: ${num_boids}`;
    }
    if (variable == "repulsion") {
        repulsion_radius = repulsion_input.value;
        repulsion_display.innerHTML = `Repulsion radius: ${repulsion_radius}`;
    }
    if (variable == "orientation") {
        orientation_radius = orientation_input.value;
        orientation_display.innerHTML = `Orientation radius: ${orientation_radius}`;
    }
    if (variable == "attraction") {
        attraction_radius = attraction_input.value;
        attraction_display.innerHTML = `Attraction radius: ${attraction_radius}`;
    }
    if (variable == "moving-speed") {
        moving_speed= moving_speed_input.value;
        moving_speed_display.innerHTML = `Moving speed: ${moving_speed}`;
    }
    if (variable == "turning-speed") {
        turning_speed = toRadian(turning_speed_input.value);
        turning_speed_display.innerHTML = `Turning speed: ${turning_speed_input.value}°`;
    }
    if (variable == "noise") {
        noise_angle = toRadian(noise_input.value);
        noise_display.innerHTML = `Noise angle: ${noise_input.value}°`;
    }
    if (variable == "blind") {
        blind_angle = toRadian(blind_input.value);
        half_visible_angle = Math.PI - blind_angle / 2;
        blind_display.innerHTML = `Blind angle: ${blind_input.value}°`;
    }
}

function initParams() {
    boids = [];

    updateParams("num-boids");

    updateParams("repulsion");
    updateParams("orientation");
    updateParams("attraction");

    updateParams("moving-speed");
    updateParams("turning-speed");
    updateParams("noise");

    updateParams("blind");

    createRandomBoids(num_boids);
    // testRepulsion();
    // testBlindSpot();
}


================================================
FILE: collective_behaviour/tests.js
================================================
function createRandomBoids(num) {
    for (let i = 0; i < num; i++) {
        let x = Math.random() * canvas_width;
        let y = Math.random() * canvas_height;
        let angle = Math.random() * 2 * Math.PI;

        let position = new Vector(x, y);
        let velocity = Vector.fromHeading(angle);

        let new_boid = new Boid(position, velocity);
        boids.push(new_boid);
    }
}

function testRepulsion() {
    let boid1 = new Boid(new Vector(canvas_width / 4, canvas_height / 2), new Vector(1, 0));
    let boid2 = new Boid(new Vector(3 * canvas_width / 4, canvas_height / 2), new Vector(-1, 0));

    boids.push(boid1);
    boids.push(boid2);
}

function testBlindSpot() {
    let boid1 = new Boid(new Vector(canvas_width / 4, canvas_height / 2), new Vector(1, 0));
    let boid2 = new Boid(new Vector(canvas_width / 4 - 0.5 * characteristic_length * repulsion_radius, canvas_height / 2), new Vector(-1, 0));

    boids.push(boid1);
    boids.push(boid2);
}


================================================
FILE: collective_behaviour/user_input.js
================================================
function clicked() {

}

function moved() {

}

function released() {

}

function keyPressed(key) {

}

function keyReleased(key) {
    
}


================================================
FILE: collective_behaviour/utils.js
================================================
function addBoids() {
    for (let i = 0; i < boid_step; i++) {
        let x = Math.random() * canvas_width;
        let y = Math.random() * canvas_height;
        let angle = Math.random() * 2 * Math.PI;

        let position = new Vector(x, y);
        let velocity = Vector.fromHeading(angle);

        let new_boid = new Boid(position, velocity);
        boids.push(new_boid);
    }
    num_boids += boid_step;
    updateParams("num-boids");
}

function removeBoids() {
    let num_removed = 0;

    while (num_removed < boid_step) {
        if (num_boids > 0) {
            boids.pop();
            num_boids--;
            num_removed++;
        }
        else {
            break;
        }
    }
    updateParams("num-boids");
}

function clearBoids() {
    boids = [];
    num_boids = 0;
    updateParams("num-boids");
}

function inBlindSpot(boid, other_boid) {
    let approach_angle = Vector.subtract(other_boid.position, boid.position).getHeading()
    let heading_angle = boid.direction;

    if (heading_angle + half_visible_angle < approach_angle && heading_angle + half_visible_angle + blind_angle > approach_angle) {
        return true;
    }
    else if (heading_angle - half_visible_angle > approach_angle && heading_angle - half_visible_angle - blind_angle < approach_angle) {
        return true;
    }
    else {
        return false;
    }
}

function getBoidsWithin(boid, radius) {
    let boids_within = [];
    
    for (let other_boid of boids) {
        if (other_boid != boid) {
            if (distanceBetween(boid.position, other_boid.position) < radius) {
                if (!inBlindSpot(boid, other_boid)) {
                    boids_within.push(other_boid);
                }
            }
        }
    }

    return boids_within;
}

function distanceBetween(vector1, vector2) {
    return Math.sqrt(Math.pow(vector1.x - vector2.x, 2) + Math.pow(vector1.y - vector2.y, 2));
}

function toRadian(angle) {
    return angle * (Math.PI / 180);
}

function toDegree(angle) {
    return angle * (180 / Math.PI);
}


================================================
FILE: collective_behaviour/Vector.js
================================================
class Vector {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }

    magnitude() {
        return Math.sqrt(Math.pow(this.x, 2) + Math.pow(this.y, 2));
    }

    negate() {
        this.x *= -1;
        this.y *= -1;
    }

    normalize() {
        let magnitude = this.magnitude();
        this.x /= magnitude;
        this.y /= magnitude;
    }

    getHeading() {
        return Math.atan2(this.y, this.x);
    }

    add(vector) {
        this.x += vector.x;
        this.y += vector.y;
    }

    scale(scale) {
        this.x *= scale;
        this.y *= scale;
    }

    static add(vector1, vector2) {
        return new Vector(vector1.x + vector2.x, vector1.y + vector2.y);
    }

    static normalize(vector) {
        let magnitude = vector.magnitude();
        return new Vector(vector.x / magnitude, vector.y / magnitude);
    }

    static dot(vector1, vector2) {
        return vector1.x * vector2.x + vector1.y * vector2.y;
    }

    static cross(vector1, vector2) {
        return vector1.x * vector2.y - vector1.y * vector2.x;
    }

    static angleBetween(vector1, vector2) {
        return Math.acos(Vector.dot(vector1, vector2) / (vector1.magnitude() * vector2.magnitude()));
    }

    static fromHeading(heading) {
        return new Vector(Math.cos(heading), Math.sin(heading));
    }

    static distanceBetween(vector1, vector2) {
        return Math.sqrt(Math.pow(vector1.x - vector2.x, 2) + Math.pow(vector1.y - vector2.y, 2));
    }

    static subtract(vector1, vector2) {
        return new Vector(vector1.x - vector2.x, vector1.y - vector2.y);
    }
}


================================================
FILE: conic_sections/basic.js
================================================
let screen_width = window.innerWidth, screen_height = window.innerHeight;
let fps = 30;

let canvas = document.getElementById("conic-canvas");
let context = canvas.getContext("2d");

let clear_button = document.getElementById("clear-button");
let draw_button = document.getElementById("draw-button");

let circle_button = document.getElementById("circle-button");
let ellipse_button = document.getElementById("ellipse-button");
let parabola_button = document.getElementById("parabola-button");
let hyperbola_button = document.getElementById("hyperbola-button");

let scale_display = document.getElementById("scale-display");

let input_e = document.getElementById("input-e");
let input_l = document.getElementById("input-l");

if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
    mobile = true;
} else {
    mobile = false;
}

if (mobile) {
    canvas_width = 0.9 * screen_width;
}
else {
    canvas_width = 0.35 * screen_width;
}
canvas_height = canvas_width;

canvas.width = canvas_width;
canvas.height = canvas_height;

let origin = canvas_width / 2;

let animate = window.requestAnimationFrame
    || window.webkitRequestAnimationFrame
    || window.mozRequestAnimationFrame
    || function (callback) {
        window.setTimeout(callback, 1000 / fps);
    };

window.onload = function() {
    initParams();
    animate(step);
}



================================================
FILE: conic_sections/conic_sections.js
================================================
let r, l, e, x, y;
let x_def, y_def;
let isDrawing, angle, angle_step;
let scale, scale_req, scale_step;
let points;

function update() {
    if (isDrawing) {
        if (angle < 2 * Math.PI) {
            angle += angle_step;

            r = l / (1 + e * Math.cos(angle));
            x = cartesianX(r, angle);
            y = cartesianY(r, angle);

            if (canDraw(e, x, y)) {
                drawPoint();
            }
        }
        else {
            isDrawing = false;
            angle = 0;
            if (!checkScaling()) {
                enableDrawButtons();
                render();
            }
        }
    }

    if (isScaling) {
        if (scale > scale_req) {
            scale *= 0.99;

            for (let point of points) {
                point.x = ((point.x - origin) * 0.99) + origin;
                point.y = origin - ((point.y - origin) * 0.99);
            }
            displayScale();
        }
        else {
            isScaling = false;
            enableDrawButtons();
            x_def = origin;
            y_def = origin;
            render();
        }
    }
}

function drawPoint() {
    if (Math.abs(x) > origin) {
        if (Math.abs(x) > x_def) {
            x_def = Math.abs(x);
        }
    }
    if (Math.abs(y) > origin) {
        if (Math.abs(y) > y_def) {
            y_def = Math.abs(y);
        }
    }
    x = transformX(x);
    y = transformY(y);

    points.push(
        {
            x: x,
            y: y,
        }
    );
}

function render() {
    context.fillStyle = "#000000";
    context.fillRect(0, 0, canvas_width, canvas_height);

    // context.strokeStyle = "#ffffff";
    // context.beginPath();
    // context.moveTo(origin, 0);
    // context.lineTo(origin, canvas_width);
    // context.stroke();

    // context.beginPath();
    // context.moveTo(0, origin);
    // context.lineTo(canvas_height, origin);
    // context.stroke();

    context.fillStyle = "#ffffff";
    if (isDrawing) {
        context.beginPath();
        context.moveTo(origin, origin);
        context.lineTo(x, y);
        context.stroke();

        context.fillText("Drawing...", 0, 30);
    }

    if (isScaling) {
        context.fillText("Rescaling...", 0, 30);
    }

    // context.strokeStyle = "#ffffff"
    // context.beginPath();
    // context.moveTo(points[0].x, points[0].y);
    // for (let i = 1; i < points.length; i++) {
    //     context.lineTo(points[i].x, points[i].y);
    // }
    // context.stroke();

    context.fillStyle = "#ffffff";
    for(let point of points) {
        context.fillRect(point.x, point.y, 3, 3);
    }
}

function step() {
    update();
    if (isDrawing || isScaling) {
        render();
    }
    animate(step);
}

function updateParams(variable) {
    if (variable == 'l') {
        l = Number.parseFloat(input_l.value);
    }
    if (variable == 'e') {
        e = Number.parseFloat(input_e.value);
    }
}

function initParams() {
    r = 0;
    l = 50;
    e = 0.9;

    x_def = origin;
    y_def = origin;

    angle = 0;
    angle_step = 0.03;
    points = [];

    isDrawing = true;
    isScaling = false;
    scale = 1;
    displayScale();

    disableDrawButtons();
    input_l.value = 50;
    input_e.value = 0.9;

    if (!mobile) {
        context.font = "30px Arial";
    }
    else {
        context.font = "20px Arial";
    }
    context.textAlign = "left";
}

function checkScaling() {
    console.log(x_def, y_def, origin);
    if (x_def > origin || y_def > origin) {
        if (x_def > y_def) {
            scale_req = (scale * canvas_width) / (2.1 * x_def);
        }
        else {
            scale_req = (scale * canvas_height) / (2.1 * y_def);
        }
        isScaling = true;
        return true;
    }
    return false;
}

function drawConic() {
    isDrawing = true;
    angle = 0;
    disableDrawButtons();
}

function drawExample(conic) {
    if (conic == "circle") {
        l = canvas_width / (3 * scale);
        e = 0;
    }
    if (conic == "ellipse") {
        l = canvas_width / (4 * scale);
        e = 0.9;
    }
    if (conic == "parabola") {
        l = 50 / scale;
        e = 1
    }
    if (conic == "hyperbola") {
        l = 50 / scale;
        e = 1.1
    }
    updateText();
    window.scrollTo(0, 100);
    drawConic();
}

function clearPoints() {
    points = [];
    scale = 1;
    isDrawing = false;
    isScaling = false;
    enableDrawButtons();
    displayScale();
    render();
}

function updateText() {
    input_l.value = `${l.toFixed()}`;
    input_e.value = `${e.toFixed()}`;
}

function enableDrawButtons() {
    draw_button.disabled = false;
    circle_button.disabled = false;
    ellipse_button.disabled = false;
    parabola_button.disabled = false;
    hyperbola_button.disabled = false;
}

function disableDrawButtons() {
    draw_button.disabled = true;
    circle_button.disabled = true;
    ellipse_button.disabled = true;
    parabola_button.disabled = true;
    hyperbola_button.disabled = true;
}

function displayScale() {
    scale_display.innerHTML = `Scale: 1 pixel = ${scale.toFixed(2)} length units`;
}

function cartesianX(r, theta) {
    return (scale * r * Math.cos(theta));
}

function cartesianY(r, theta) {
    return (scale * r * Math.sin(theta));
}

function transformX(x) {
    return origin + x;
}

function transformY(y) {
    return origin - y;
}

function canDraw(e, x, y) {
    return (Math.abs(e) < 1 || (Math.abs(transformX(x)) < 2 * canvas_width && Math.abs(transformY(y)) < 2 * canvas_height))
}



================================================
FILE: conic_sections/simulation.html
================================================
<!DOCTYPE html>
<html lang="en-US">

<head>
    <title>Conic Sections | Visualize It</title>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- Materialize -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/js/materialize.min.js"></script>
    <script src="basic.js" defer></script>
    <script src="conic_sections.js" defer></script>
    <script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

    <!-- CSS -->
    <link rel="stylesheet" href="../style.css" />
</head>

<script async src="https://www.googletagmanager.com/gtag/js?id=G-M95CKRP8HB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){window.dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-M95CKRP8HB');
</script>

<body>
    <nav class="nav-extended" style="background:black; margin-top: 0mm">
        <div class="nav-wrapper">
            <h1 id="main-heading">Visualize It</h1>
        </div>
        <div class="nav-content">
            <ul class="tabs tabs-transparent tabs-fixed-width">
                <li class="tab"><a href="../index.html">Home</a></li>
                <li class="tab"><a href="../about.html">About</a></li>
            </ul>
        </div>
    </nav>
</body>

<div class="text">
    <h4>Visualization of Conic Sections</h4>
    <p>Conic sections refer to the geometric figures obtained upon intersecting a cone with a plane making different angles with its axis. In polar coordinates, all conic sections are represented by a single equaion.</p>
    <center>
        <canvas id="conic-canvas"></canvas>
        <p id="scale-display"></p>
        <button id="clear-button" onclick="clearPoints()" class="btn purple darken-4">Clear</button>
        <button id="draw-button" onclick="drawConic()" class="btn purple darken-4">Draw</button>
        <br>
        <div class="container" style="width: 100%">
            <div class="row">
                <div class="col m6">
                    <p>Length of Semi Latus-rectum</p>
                    <input oninput="updateParams('l')" placeholder="L" type="number" id="input-l">
                </div>
                <div class="col m6">
                    <p>Eccentricity</p>
                    <input oninput="updateParams('e')" placeholder="e" type="number" id="input-e">
                </div>
            </div>
        </div>
    </center>

    <br>
    <hr>
    <br>

    <h5>Brief description</h5>
    <p>The equation of a conic with a semi latus-rectum length of 'L' and eccentricity of 'e' is given by</p>
    \[ r = \frac{l}{1 + e \cos \theta} \]
    <p>The corresponding (r, &theta;) can be converted into cartesian coordinates (x, y) and plotted</p>
    <br>
    <b>Circle</b>
    <p>When the plane is perpendicular to the conical axis, the conic section obtained is a circle. The semi latus-rectum is just the radius. Circles have an eccentricity of 0.</p>
    <center>
        <button id="circle-button" class="btn purple darken-4" onclick="drawExample('circle')">Draw</button>
    </center>
    <br>
    <b>Ellipse</b>
    <p>When the plane makes an angle more than the semi-vertical angle of the cone but less than 90<sup>o</sup>, the conic section obtained is an ellipse. It like a bloated circle. Ellipses have an absolute eccentricity between 0 and 1 (exclusive).</p>
    <center>
        <button id="ellipse-button" class="btn purple darken-4" onclick="drawExample('ellipse')">Draw</button>
    </center>
    <br>
    <b>Parabola</b>
    <p>When the plane makes an angle lesser than the semi-vertical angle of the cone but intersections only a single motif, the conic section obtained is a parabola. They have an absolute eccentricity of 1</p>
    <center>
        <button id="parabola-button" class="btn purple darken-4" onclick="drawExample('parabola')">Draw</button>
    </center>
    <br>
    <b>Hyperbola</b>
    <p>When the plane intersects both the conical motifs, the conic section obtained is a hyperbola. They have an absolute eccentricity greater than 1.</p>
    <center>
        <button id="hyperbola-button" class="btn purple darken-4" onclick="drawExample('hyperbola')">Draw</button>
    </center>

    <br>
    <hr>
    <br>

    <b>Note:</b>
    <ol>
        <li>Due to their open-ended nature, parabolas and hyperbolas extend into infinity. They are not efficiently drawn here.</li>
        <li>Circles and Ellipses of huge lengths can be drawn. However, the curve may seem broken and a lot of time will be required to rescale</li>
        <li>All draw buttons are disabled during drawing and scaling</li>
    </ol>

    <br>
    <hr>
    <br>

    <p class="center-align">Developed by ChanRT | Fork me at <a href="https://www.github.com/chanrt">GitHub</a></p>
</div>

</html>



================================================
FILE: contact_process/basic.js
================================================
let screen_width = window.innerWidth, screen_height = window.innerHeight;
let canvas_width, canvas_height;
let fps = 24, paused = false, accelerated = false;
let mobile;

if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
    mobile = true;
} else {
    mobile = false;
}

let canvas = document.getElementById("canvas");
let context = canvas.getContext("2d");

let prob_input = getElement("prob-input");
let prob_display = getElement("prob-display");

let num_input = getElement("num-input");
let num_display = getElement("num-display");

let pause_button = getElement("pause-button");

if (mobile) {
    canvas_width = 0.9 * screen_width;
}
else {
    canvas_width = 0.4 * screen_width;
}
canvas_height = canvas_width;

canvas.width = canvas_width;
canvas.height = canvas_height;

let animate;
if(accelerated) {
    animate = window.requestAnimationFrame
    || window.webkitRequestAnimationFrame
    || window.mozRequestAnimationFrame
    || function (callback) {
        window.setTimeout(callback, 1000 / fps);
    };
}
else {
    animate = function (callback) {
        window.setTimeout(callback, 1000 / fps);
    };
}



function step() {
    if (!paused) {
        update();
    }
    render();
    animate(step);
}

window.onload = function () {
    initParams();
    animate(step);
}

let click_x, click_y, pressed;

if (mobile) {
    canvas.addEventListener("touchstart", function (e) {
        getTouchPosition(canvas, e);
        let touch = e.touches[0];
        let mouseEvent = new MouseEvent("mousedown", {
            clientX: touch.clientX,
            clientY: touch.clientY
        });
        canvas.dispatchEvent(mouseEvent);
        pressed = true;
        clicked();
    }, false);

    canvas.addEventListener("touchmove", function (e) {
        getTouchPosition(canvas, e);
        let touch = e.touches[0];
        let mouseEvent = new MouseEvent("mousemove", {
            clientX: touch.clientX,
            clientY: touch.clientY
        });
        canvas.dispatchEvent(mouseEvent);
        moved();
    }, false);

    canvas.addEventListener("touchend", function (e) {
        getTouchPosition(canvas, e);
        let touch = e.touches[0];
        let mouseEvent = new MouseEvent("mouseup", {
            clientX: touch.clientX,
            clientY: touch.clientY
        });
        canvas.dispatchEvent(mouseEvent);
        pressed = false;
        released();
    }, false);
}
else {
    canvas.addEventListener("mousedown", function (e) {
        getMousePosition(canvas, e);
        pressed = true;
        clicked();
    });

    canvas.addEventListener("mousemove", function (e) {
        getMousePosition(canvas, e);
        moved();
    });

    canvas.addEventListener("mouseup", function (e) {
        getMousePosition(canvas, e);
        pressed = false;
        released();
    });

    window.addEventListener("keydown", function (e) {
        keyPressed(e.keyCode);
    }, false);

    window.addEventListener("keydown", function (e) {
        keyReleased(e.keyCode);
    }, false);
}

function getMousePosition(canvas, event) {
    rect = canvas.getBoundingClientRect();
    click_x = event.clientX - rect.left;
    click_y = event.clientY - rect.top;
}

function getTouchPosition(canvas, event) {
    var rect = canvas.getBoundingClientRect();
    click_x = event.touches[0].clientX - rect.left;
    click_y = event.touches[0].clientY - rect.top;
}


================================================
FILE: contact_process/contact_process.js
================================================
let grid;

let cells_length, square_length;

let prob;
let spawned, killed;
let spawn_location, kill_location;

let num_epochs, num_steps, num_max;

function update() {
    num_steps++;
    if (num_steps == num_max) {
        num_steps = 0;
        num_epochs++;
    }

    spawned = false;
    killed = false;

    let random_row, random_col;
    if (!isExtinct()) {
        do {
            random_row = Math.floor(Math.random() * cells_length);
            random_col = Math.floor(Math.random() * cells_length);
        } while (grid[random_row][random_col] != 1);
        // find an alive cell

        if (Math.random() < prob) {
            // spawn
            let neighbour_cell = Math.floor(Math.random() * 4);

            if (neighbour_cell == 0) {
                // top
                if (random_row == 0) {
                    spawnAt(cells_length - 1, random_col);
                }
                else {
                    spawnAt(random_row - 1, random_col);
                }
            }
            else if (neighbour_cell == 1) {
                // left
                if (random_col == cells_length - 1) {
                    spawnAt(random_row, 0);
                }
                else {
                    spawnAt(random_row, random_col + 1);
                }
            }
            else if (neighbour_cell == 3) {
                // bottom
                if (random_row == cells_length - 1) {
                    spawnAt(0, random_col);
                }
                else {
                    spawnAt(random_row + 1, random_col);
                }
            }
            else if (neighbour_cell == 4) {
                // right
                if (random_col == 0) {
                    spawnAt(random_row, cells_length - 1);
                }
                else {
                    spawnAt(random_row, random_col - 1);
                }
            }
        }
        else {
            // kill
            grid[random_row][random_col] = 0;
            killed = true;
            kill_location = {
                row: random_row,
                col: random_col,
            };
        }
    }
}

function render() {
    context.fillStyle = "#000000";
    context.fillRect(0, 0, canvas_width, canvas_height);

    context.strokeStyle = "#ffffff";
    // horizontal lines
    for (let i = 1; i < cells_length; i++) {
        context.beginPath();
        context.moveTo(0, i * square_length);
        context.lineTo(canvas_width, i * square_length);
        context.stroke();
    }

    // vertical lines
    for (let j = 1; j < cells_length; j++) {
        context.beginPath();
        context.moveTo(j * square_length, 0);
        context.lineTo(j * square_length, canvas_height);
        context.stroke();
    }

    context.fillStyle = "#999999";
    for (let i = 0; i < cells_length; i++) {
        for (let j = 0; j < cells_length; j++) {
            if (grid[i][j] == 1) {
                context.fillRect(j * square_length, i * square_length, square_length, square_length);
            }
        }
    }

    if(spawned) {
        context.fillStyle = "#0000ff";
        context.fillRect(spawn_location.col * square_length, spawn_location.row * square_length, square_length, square_length);
    }

    if(killed) {
        context.fillStyle = "#ff0000";
        context.fillRect(kill_location.col * square_length, kill_location.row * square_length, square_length, square_length);
    }
}

function updateParams(variable) {
    if(variable == "prob") {
        prob = prob_input.value;
        prob_display.innerHTML = `Probability of birth: ${prob}`;
    }
    if(variable == "num") {
        cells_length = num_input.value;
        num_display.innerHTML = `Grid size: ${cells_length} x ${cells_length}`;
        initialize();
    }
}

function initialize() {
    square_length = canvas_width / cells_length;
    grid = new2dArray(cells_length, cells_length);

    num_epochs = 0;
    num_steps = 0;
    num_max = cells_length * cells_length;
}

function initParams() {
    num_input.value = 10;
    updateParams("num");
    prob_input.value = 0.8;
    updateParams("prob");

    initialize();
}

function pauseToggle() {
    if(!paused) {
        paused = true;
        pause_button.innerHTML = "Resume";
    }
    else {
        paused = false;
        pause_button.innerHTML = "Pause";
    }
}

function clearGrid() {
    for (let i = 0; i < cells_length; i++) {
        for (let j = 0; j < cells_length; j++) {
            grid[i][j] = 0;
        }
    }
    spawned = false;
    killed = false;
}

function isExtinct() {
    for (let i = 0; i < cells_length; i++) {
        for (let j = 0; j < cells_length; j++) {
            if (grid[i][j] == 1) {
                return false;
            }
        }
    }
    return true;
}

function spawnAt(row, col) {
    if(grid[row][col] == 0) {
        grid[row][col] = 1;
        spawned = true;
        spawn_location = {
            row: row,
            col: col
        }
    }
}


================================================
FILE: contact_process/simulation.html
================================================
<!DOCTYPE html>
<html lang="en-US">

<head>
  <title>Contact Process | Visualize It</title>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="keywords" content="contact process, automaton">
  <meta name="og:image"
    content="https://github.com/visualize-it/visualize-it.github.io/raw/main/images_webp/contact_process.webp">

  <!-- Materialize -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/js/materialize.min.js"></script>

  <script src="../helper.js" defer></script>
  <script src="basic.js" defer></script>
  <script src="user_input.js" defer></script>
  <script src="contact_process.js" defer></script>

  <script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML">
    </script>

  <!-- CSS -->
  <link rel="stylesheet" href="../style.css" />
</head>

<script async src="https://www.googletagmanager.com/gtag/js?id=G-M95CKRP8HB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() { window.dataLayer.push(arguments); }
  gtag('js', new Date());

  gtag('config', 'G-M95CKRP8HB');
</script>

<body>
  <nav class="nav-extended" style="background:black; margin-top: 0mm">
    <div class="nav-wrapper">
      <h1 id="main-heading">Visualize It</h1>
    </div>
    <div class="nav-content">
      <ul class="tabs tabs-transparent tabs-fixed-width">
        <li class="tab"><a href="../index.html" style="font-size: larger;">Home</a></li>
        <li class="tab"><a href="../about.html" style="font-size: larger;">About</a></li>
      </ul>
    </div>
  </nav>
</body>

<div class="text">
  <h2>Contact Process</h2>
  <p>
    In the context of Stochastic and Spatial Dynamics, Contact Process is used to model population growth in a set of
    interactive cells. In essence, it is a randomised cellular automaton: a zero player game that follows a set of rules
    coupled with randomness.
  </p>

  <hr>

  <h3>Simulation</h3>

  <p>
    The model comprises a 2D lattice of cells. Each cell can be dead (black) or alive (gray). Alive cells can die (red)
    or dead cells can be born (blue). The algorithm is as follows:
  <ol class="browser-default">
    <li>Select a random cell</li>
    <li>If the selected cell is empty, then repeat the previous step. If the selected cell is occupied, then proceed to
      next step with the selected cell as the 'current cell'</li>
    <li>The next step is probabilistic, with a probability 'p' of birth and '1-p' of death</li>
    <ol>
      <li>
        <b>Birth:</b> Randomly select a cell adjacent to the current cell. If it is empty, then spawn an occupant there.
        If it is already occupied then do nothing
      </li>
      <li>
        <b>Death:</b> Kill the occupant of the current cell
      </li>
    </ol>
    <li>Repeat from the beginning</li>
  </ol>
  </p>

  <div class="container">
    <div class="row">
      <div class="col s12 l8">
        <canvas id="canvas"></canvas>
      </div>
      <div class="col s12 l4">
        <center>
          <b>
            Click on a cell to toggle it's state. Consider pausing the simulation
            <br>
            Blue - Birth ; Red - Death
          </b>
          <br> <br>
          <button id="pause-button" class="btn purple darken-4" onclick="pauseToggle()">Pause</button>
          <button class="btn purple darken-4" onclick="clearGrid()">Clear</button>
          <br> <br>
          <span id="prob-display"></span>
          <input id="prob-input" type="range" min="0" max="1" step="0.01" oninput="updateParams('prob')"
            onchange="updateParams('prob')">
          <p>Updates to probability get reflected immediately</p>
          <br> <br>
          <span id="num-display"></span>
          <input id="num-input" type="range" min="2" max="20" step="1" oninput="updateParams('num')"
            onchange="updateParams('num')">
          <p>Grid gets cleared when size is updated</p>
        </center>
      </div>
    </div>
  </div>

  <br>
  <hr>
  <br>

  <b>Note:</b>
  <ol>
    <li>If p < 0.5, then there is a pretty high chance that your population will go extinct within a couple of
        steps</li>
    <li>If you want to paint a pattern and watch it's evolution, then pause the simulation while doing so</li>
    <li>
      Related: <a href="../bernoulli_percolation/simulation.html">Bernoulli Percolation</a>, 
      <a href="../tdp/simulation.html">Directed Percolation</a>, 
      <a href="../porous_percolation/simulation.html">Porous Percolation</a>.
    </li>
  </ol>

  <br>
  <hr>

  <p class="center-align">Developed by ChanRT | Fork me at <a href="https://www.github.com/chanrt">GitHub</a></p>
</div>

</html>


================================================
FILE: contact_process/user_input.js
================================================
function clicked() {
    let row_num = Math.floor(click_y / square_length);
    let col_num = Math.floor(click_x / square_length);

    grid[row_num][col_num] = (grid[row_num][col_num] == 1) ? 0 : 1;
}

function moved() {

}

function released() {

}

function keyPressed(key) {

}

function keyReleased(key) {
    
}


================================================
FILE: conway_game/basic.js
================================================
let screen_width = window.innerWidth, screen_height = window.innerHeight;
let fps = 10;

let canvas = document.getElementById("canvas");
let context = canvas.getContext("2d");

let pause_button = document.getElementById("pause-button");
let border_toggle = document.getElementById("border-toggle");
let grid_button = document.getElementById("grid-button");

let cell_slider = document.getElementById("cell-slider");
let cell_display = document.getElementById("cell-display");

let fps_slider = document.getElementById("fps-slider");
let fps_display = document.getElementById("fps-display");


if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
  mobile = true;
  canvas.addEventListener("touchstart", function (e) {
    getTouchPosition(canvas, e);
    let touch = e.touches[0];
    let mouseEvent = new MouseEvent("mousedown", {
      clientX: touch.clientX,
      clientY: touch.clientY
    });
    canvas.dispatchEvent(mouseEvent);
  }, false);

} else {
  mobile = false;
  canvas.addEventListener("mousedown", function (e) {
    getMousePosition(canvas, e);
  });
}

if (mobile) {
  canvas_width = 0.95 * screen_width;
}
else {
  canvas_width = 0.45 * screen_width;
}
canvas_height = canvas_width

canvas.width = canvas_width;
canvas.height = canvas_height;

let animate = function (callback) {
  window.setTimeout(callback, 1000 / fps);
};

window.onload = function () {
  initParams();
  animate(step);
}

function step() {
  if (!isPaused) {
    update();
  }
  render();
  animate(step);
}

function getMousePosition(canvas, event) {
  rect = canvas.getBoundingClientRect();
  click_x = event.clientX - rect.left;
  click_y = event.clientY - rect.top;
  manageClick();
}

function getTouchPosition(canvas, event) {
  var rect = canvas.getBoundingClientRect();
  click_x = event.touches[0].clientX - rect.left,
    click_y = event.touches[0].clientY - rect.top
  manageClick();
}

function manageClick() {
  toggle(Math.floor(click_x / cell_length), Math.floor(click_y / cell_length));
  if (!isPaused) {
    togglePause();
  }
}

function toggleGrid() {
  if (showGrid) {
    showGrid = false;
    grid_button.innerHTML = "Show grid";
  }
  else {
    showGrid = true;
    grid_button.innerHTML = "Hide grid";
  }
}

function togglePause() {
  pause_button.innerHTML = isPaused ? "Pause" : "Resume";
  isPaused = isPaused ? false : true;
}

function toggleBorder() {
  borderInteract = borderInteract ? false : true
  border_toggle.innerHTML = borderInteract ? "Disable border interactions" : "Enable border interactions";
}

function delaySet(delay) {
  animate = function (callback) {
    window.setTimeout(callback, delay);
  };
  animate(step);
}

function alwaysResume() {
  if (isPaused) {
    togglePause();
  }
}

function disableBorder() {
  if (borderInteract) {
    toggleBorder();
  }
}

function enableBorder() {
  if (!borderInteract) {
    toggleBorder();
  }
}

function configSlider() {
  cell_slider.value = num_cells;
}

function scrollUp() {
  window.scrollTo(0, 500);
}



================================================
FILE: conway_game/conway_game.js
================================================
// cell related
let cells, neighbours, num_cells, cell_length;
let grid;

// simulation related
let next_state, num_neigh;

// event
let rect, click_x, click_y;

// states
let isPaused, showGrid, borderInteract;

function update() {
  prepareNextState();
  middleGround();
  if (borderInteract) {
    edgeGround();
    cornerGround();
  }
  copyNextState();
}

function render() {
  context.fillStyle = "#000000";
  context.fillRect(0, 0, canvas_width, canvas_height);

  if (showGrid) {
    drawGrid();
  }

  context.fillStyle = "#ffffff";
  for (let i = 0; i < num_cells; i++) {
    for (let j = 0; j < num_cells; j++) {
      if (cells[i][j]) {
        if (neighbours[i][j] == 1) {
          context.fillStyle = "#ffffff";
        }
        else if (neighbours[i][j] == 2) {
          context.fillStyle = "#ffa500";
        }
        else if (neighbours[i][j] == 3) {
          context.fillStyle = "#1f51ff";
        }
        else {
          context.fillStyle = "#ff0000";
        }
        context.fillRect(grid[i], grid[j], cell_length, cell_length);
      }
    }
  }
}

function drawGrid() {
  context.strokeStyle = "#aaaaaa";
  context.lineWidth = 0.75;
  for (let latitude of grid) {
    context.beginPath();
    context.moveTo(0, latitude);
    context.lineTo(canvas_width, latitude);
    context.stroke();
  }
  for (let longitude of grid) {
    context.beginPath();
    context.moveTo(longitude, 0);
    context.lineTo(longitude, canvas_height);
    context.stroke();
  }
}

function updateParams(variable) {
  if (variable == "cells") {
    num_cells = cell_slider.value;
    cell_display.innerHTML = `Number of cells per row/column: ${num_cells}`;

    grid = [];
    cells = [];
    showGrid = true;
    grid_button.innerHTML = "Hide Grid";

    if (!isPaused) {
      togglePause();
    }

    initCanvas();
  }
  if (variable == "fps") {
    fps = fps_slider.value;
    fps_display.innerHTML = `Frames per second: ${fps}`;

    animate = function (callback) {
      window.setTimeout(callback, 1000 / fps);
    };
  }
}

function initParams() {
  num_cells = 10;
  grid = [];
  cells = [];
  neighbours = [];

  cell_slider.value = num_cells;

  fps_slider.value = fps;
  updateParams("fps");

  initCanvas();

  isPaused = false;
  showGrid = false;
  borderInteract = true;

  gosperState();
}

function toggle(i, j) {
  if (i < num_cells && j < num_cells) {
    cells[i][j] = cells[i][j] ? 0 : 1;
  }
  else {
    console.log("Out of bounds")
  }
}

function initCanvas() {
  cell_length = canvas_width / num_cells;
  grid = [];

  for (let pos = 1; pos < canvas_width; pos += cell_length) {
    grid.push(pos);
  }
  grid.push(canvas_width - 1);

  cell_display.innerHTML = `Number of cells per row/column: ${num_cells}`;
  resetCells();
}


================================================
FILE: conway_game/engine.js
================================================
function middleGround() {
  for (let i = 1; i < num_cells - 1; i++) {
    for (let j = 1; j < num_cells - 1; j++) {
      num_neigh = getNumNeighbours(i, j);
      neighbours[i][j] = num_neigh;
      decideState(i, j, num_neigh);
    }
  }
}

function edgeGround() {
  upperEdge();
  lowerEdge();
  leftEdge();
  rightEdge();
}

function cornerGround() {
  upperLeft();
  upperRight();
  lowerLeft();
  lowerRight();
}

function getNumNeighbours(i, j) {
  let num = 0;
  if (cells[i - 1][j - 1]) {
    num++;
  }
  if (cells[i - 1][j]) {
    num++;
  }
  if (cells[i - 1][j + 1]) {
    num++;
  }
  if (cells[i][j - 1]) {
    num++;
  }
  if (cells[i][j + 1]) {
    num++;
  }
  if (cells[i + 1][j - 1]) {
    num++;
  }
  if (cells[i + 1][j]) {
    num++;
  }
  if (cells[i + 1][j + 1]) {
    num++;
  }
  neighbours[i][j] = num_neigh;
  return num;
}

function upperEdge() {
  for (let j = 1; j < num_cells - 1; j++) {
    num_neigh = 0;
    if (cells[0][j - 1]) {
      num_neigh++;
    }
    if (cells[0][j + 1]) {
      num_neigh++;
    }
    if (cells[1][j - 1]) {
      num_neigh++;
    }
    if (cells[1][j]) {
      num_neigh++;
    }
    if (cells[1][j + 1]) {
      num_neigh++;
    }
    if (cells[num_cells - 1][j - 1]) {
      num_neigh++;
    }
    if (cells[num_cells - 1][j]) {
      num_neigh++;
    }
    if (cells[num_cells - 1][j + 1]) {
      num_neigh++;
    }
    neighbours[0][j] = num_neigh;
    decideState(0, j, num_neigh);
  }
}

function lowerEdge() {
  for (let j = 1; j < num_cells - 1; j++) {
    num_neigh = 0;
    if (cells[num_cells - 1][j - 1]) {
      num_neigh++;
    }
    if (cells[num_cells - 1][j + 1]) {
      num_neigh++;
    }
    if (cells[num_cells - 2][j - 1]) {
      num_neigh++;
    }
    if (cells[num_cells - 2][j]) {
      num_neigh++;
    }
    if (cells[num_cells - 2][j + 1]) {
      num_neigh++;
    }
    if (cells[0][j - 1]) {
      num_neigh++;
    }
    if (cells[0][j]) {
      num_neigh++;
    }
    if (cells[0][j + 1]) {
      num_neigh++;
    }
    neighbours[num_cells - 1][j] = num_neigh;
    decideState(num_cells - 1, j, num_neigh);
  }
}

function leftEdge() {
  for (let i = 1; i < num_cells - 1; i++) {
    num_neigh = 0;
    if (cells[i - 1][0]) {
      num_neigh++;
    }
    if (cells[i + 1][0]) {
      num_neigh++;
    }
    if (cells[i - 1][1]) {
      num_neigh++;
    }
    if (cells[i][1]) {
      num_neigh++;
    }
    if (cells[i + 1][1]) {
      num_neigh++;
    }
    if (cells[i - 1][num_cells - 1]) {
      num_neigh++;
    }
    if (cells[i][num_cells - 1]) {
      num_neigh++;
    }
    if (cells[i + 1][num_cells - 1]) {
      num_neigh++;
    }
    neighbours[i][0] = num_neigh;
    decideState(i, 0, num_neigh);
  }
}

function rightEdge() {
  for (let i = 1; i < num_cells - 1; i++) {
    num_neigh = 0;
    if (cells[i - 1][num_cells - 1]) {
      num_neigh++;
    }
    if (cells[i + 1][num_cells - 1]) {
      num_neigh++;
    }
    if (cells[i - 1][0]) {
      num_neigh++;
    }
    if (cells[i][0]) {
      num_neigh++;
    }
    if (cells[i + 1][0]) {
      num_neigh++;
    }
    if (cells[i - 1][num_cells - 2]) {
      num_neigh++;
    }
    if (cells[i][num_cells - 2]) {
      num_neigh++;
    }
    if (cells[i + 1][num_cells - 2]) {
      num_neigh++;
    }
    neighbours[i][num_cells - 1] = num_neigh;
    decideState(i, num_cells - 1, num_neigh);
  }
}

function upperLeft() {
  num_neigh = 0;
  if (cells[0][1]) {
    num_neigh++;
  }
  if (cells[1][0]) {
    num_neigh++;
  }
  if (cells[1][1]) {
    num_neigh++;
  }
  if (cells[0][num_cells - 1]) {
    num_neigh++;
  }
  if (cells[1][num_cells - 1]) {
    num_neigh++;
  }
  if (cells[num_cells - 1][0]) {
    num_neigh++;
  }
  if (cells[num_cells - 1][1]) {
    num_neigh++;
  }
  if (cells[num_cells - 1][num_cells - 1]) {
    num_neigh++;
  }
  neighbours[0][0] = num_neigh;
  decideState(0, 0, num_neigh);
}

function upperRight() {
  num_neigh = 0;
  if (cells[0][0]) {
    num_neigh++;
  }
  if (cells[1][0]) {
    num_neigh++;
  }
  if (cells[0][num_cells - 2]) {
    num_neigh++;
  }
  if (cells[1][num_cells - 2]) {
    num_neigh++;
  }
  if (cells[1][num_cells - 1]) {
    num_neigh++;
  }
  if (cells[num_cells - 1][num_cells - 2]) {
    num_neigh++;
  }
  if (cells[num_cells - 1][num_cells - 1]) {
    num_neigh++;
  }
  if (cells[num_cells - 1][0]) {
    num_neigh++;
  }
  neighbours[0][num_cells - 1] = num_neigh;
  decideState(0, num_cells - 1, num_neigh);
}

function lowerLeft() {
  num_neigh = 0;
  if (cells[0][0]) {
    num_neigh++;
  }
  if (cells[0][1]) {
    num_neigh++;
  }
  if (cells[0][num_cells - 1]) {
    num_neigh++;
  }
  if (cells[num_cells - 2][num_cells - 1]) {
    num_neigh++;
  }
  if (cells[num_cells - 1][num_cells - 1]) {
    num_neigh++;
  }
  if (cells[num_cells - 2][0]) {
    num_neigh++;
  }
  if (cells[num_cells - 2][1]) {
    num_neigh++;
  }
  if (cells[num_cells - 1][1]) {
    num_neigh++;
  }
  neighbours[num_cells - 1][0] = num_neigh;
  decideState(num_cells - 1, 0, num_neigh);
}

function lowerRight() {
  num_neigh = 0;
  if (cells[0][0]) {
    num_neigh++;
  }
  if (cells[0][num_cells - 1]) {
    num_neigh++;
  }
  if (cells[0][num_cells - 2]) {
    num_neigh++;
  }
  if (cells[num_cells - 2][num_cells - 1]) {
    num_neigh++;
  }
  if (cells[num_cells - 1][num_cells - 2]) {
    num_neigh++;
  }
  if (cells[num_cells - 2][num_cells - 2]) {
    num_neigh++;
  }
  if (cells[num_cells - 1][0]) {
    num_neigh++;
  }
  if (cells[num_cells - 2][0]) {
    num_neigh++;
  }
  neighbours[num_cells - 1][num_cells - 1] = num_neigh;
  decideState(num_cells - 1, num_cells - 1, num_neigh);
}

function decideState(i, j, num_neigh) {
  if (cells[i][j]) {
    if (num_neigh < 2 || num_neigh > 3) {
      next_state[i][j] = 0;
    }
    else {
      next_state[i][j] = 1;
    }
  }
  else {
    if (num_neigh == 3) {
      next_state[i][j] = 1;
    }
    else {
      next_state[i][j] = 0;
    }
  }
}



================================================
FILE: conway_game/predef.js
================================================
function genCode() {
  let string = `num_cells = ${num_cells}; initCanvas();`;
  for (let i = 0; i < num_cells; i++) {
    for (let j = 0; j < num_cells; j++) {
      if (cells[i][j]) {
        string += `toggle(${i},${j});`;
      }
    }
  }
  string += "alwaysResume();configSlider()";
  console.log(string);
}

// Steady states
function beehiveState() {
  num_cells = 6;
  initCanvas();
  toggle(2, 1);
  toggle(1, 2);
  toggle(3, 2);
  toggle(1, 3);
  toggle(3, 3);
  toggle(2, 4);
  alwaysResume();
  configSlider();
  scrollUp();
}

function boatState() {
  num_cells = 5;
  initCanvas();
  toggle(1, 1);
  toggle(1, 2);
  toggle(2, 1);
  toggle(2, 3);
  toggle(3, 2);
  alwaysResume();
  configSlider();
  scrollUp();
}

function blockState() {
  num_cells = 4;
  initCanvas();
  toggle(1, 1);
  toggle(1, 2);
  toggle(2, 1);
  toggle(2, 2);
  alwaysResume();
  configSlider();
  scrollUp();
}

function loafState() {
  num_cells = 6;
  initCanvas();
  toggle(1, 2);
  toggle(1, 3);
  toggle(2, 1);
  toggle(2, 4);
  toggle(3, 2);
  toggle(3, 4);
  toggle(4, 3);
  alwaysResume();
  configSlider();
  scrollUp();
}

function tubState() {
  num_cells = 5;
  initCanvas();
  toggle(1, 2);
  toggle(2, 1);
  toggle(2, 3);
  toggle(3, 2);
  alwaysResume();
  configSlider();
  scrollUp();
}

// Oscillators
function beaconState() {
  num_cells = 6; initCanvas(); toggle(1, 1); toggle(1, 2); toggle(2, 1); toggle(3, 4); toggle(4, 3); toggle(4, 4); alwaysResume();
  configSlider();
  scrollUp();
}

function blinkerState() {
  num_cells = 5; initCanvas(); toggle(2, 1); toggle(2, 2); toggle(2, 3); alwaysResume();
  configSlider();
  scrollUp();
}

function pentaState() {
  num_cells = 18; initCanvas(); toggle(7, 6); toggle(7, 11); toggle(8, 4); toggle(8, 5); toggle(8, 7); toggle(8, 8); toggle(8, 9); toggle(8, 10); toggle(8, 12); toggle(8, 13); toggle(9, 6); toggle(9, 11); alwaysResume();
  configSlider();
  scrollUp();
}

function pulsarState() {
  num_cells = 17; initCanvas(); toggle(2, 4); toggle(2, 5); toggle(2, 6); toggle(2, 10); toggle(2, 11); toggle(2, 12); toggle(4, 2); toggle(4, 7); toggle(4, 9); toggle(4, 14); toggle(5, 2); toggle(5, 7); toggle(5, 9); toggle(5, 14); toggle(6, 2); toggle(6, 7); toggle(6, 9); toggle(6, 14); toggle(7, 4); toggle(7, 5); toggle(7, 6); toggle(7, 10); toggle(7, 11); toggle(7, 12); toggle(9, 4); toggle(9, 5); toggle(9, 6); toggle(9, 10); toggle(9, 11); toggle(9, 12); toggle(10, 2); toggle(10, 7); toggle(10, 9); toggle(10, 14); toggle(11, 2); toggle(11, 7); toggle(11, 9); toggle(11, 14);
  toggle(12, 2); toggle(12, 7); toggle(12, 9); toggle(12, 14); toggle(14, 4); toggle(14, 5); toggle(14, 6); toggle(14, 10); toggle(14, 11); toggle(14, 12); alwaysResume();
  configSlider();
  scrollUp();
}

function toadState() {
  num_cells = 6; initCanvas(); toggle(1, 3); toggle(2, 2); toggle(2, 3); toggle(3, 2); toggle(3, 3); toggle(4, 2); alwaysResume();
  configSlider();
  scrollUp();
}

// Spaceships
function gliderState() {
  num_cells = 20; initCanvas(); toggle(1, 6); toggle(2, 4); toggle(2, 6); toggle(3, 5); toggle(3, 6); alwaysResume();
  configSlider();
  enableBorder();
  scrollUp();
}

function lwssState() {
  num_cells = 20; initCanvas(); toggle(1, 3); toggle(1, 5); toggle(2, 6); toggle(3, 6); toggle(4, 3); toggle(4, 6); toggle(5, 4); toggle(5, 5); toggle(5, 6); alwaysResume();
  configSlider();
  enableBorder();
  scrollUp();
}

function hwssState() {
  num_cells = 20; initCanvas(); toggle(3, 7); toggle(3, 8); toggle(3, 9); toggle(4, 6); toggle(4, 9); toggle(5, 9); toggle(6, 5); toggle(6, 9); toggle(7, 5); toggle(7, 9); toggle(8, 9); toggle(9, 6); toggle(9, 8); alwaysResume();
  configSlider();
  enableBorder();
  scrollUp();
}

// Methulselahs
function pentaminoState() {
  num_cells = 40; initCanvas(); toggle(19, 18); toggle(20, 17); toggle(20, 18); toggle(20, 19); toggle(21, 17); alwaysResume();
  configSlider();
  disableBorder();
  scrollUp();
}

function diehardState() {
  num_cells = 40; initCanvas(); toggle(16, 19); toggle(17, 19); toggle(17, 20); toggle(21, 20); toggle(22, 18); toggle(22, 20); toggle(23, 20); alwaysResume();
  configSlider();
  disableBorder();
  scrollUp();
}

function acornState() {
  num_cells = 40; initCanvas(); toggle(16, 20); toggle(17, 18); toggle(17, 20); toggle(19, 19); toggle(20, 20); toggle(21, 20); toggle(22, 20); alwaysResume();
  configSlider();
  disableBorder();
  scrollUp();
}

// GLider Guns
function gosperState() {
  num_cells = 40; initCanvas(); toggle(1, 5); toggle(1, 6); toggle(2, 5); toggle(2, 6); toggle(11, 5); toggle(11, 6); toggle(11, 7); toggle(12, 4); toggle(12, 8); toggle(13, 3); toggle(13, 9); toggle(14, 3); toggle(14, 9); toggle(15, 6); toggle(16, 4); toggle(16, 8); toggle(17, 5); toggle(17, 6); toggle(17, 7); toggle(18, 6); toggle(21, 3); toggle(21, 4); toggle(21, 5); toggle(22, 3); toggle(22, 4); toggle(22, 5); toggle(23, 2); toggle(23, 6); toggle(25, 1); toggle(25, 2); toggle(25, 6); toggle(25, 7); toggle(35, 3); toggle(35, 4); toggle(36, 3); toggle(36, 4); alwaysResume();
  configSlider();
  disableBorder();
  scrollUp();
}

function simkinState() {
  num_cells = 35; initCanvas(); toggle(1, 1); toggle(1, 2); toggle(2, 1); toggle(2, 2); toggle(5, 4); toggle(5, 5); toggle(6, 4); toggle(6, 5); toggle(8, 1); toggle(8, 2); toggle(9, 1); toggle(9, 2); toggle(21, 18); toggle(21, 19); toggle(22, 11); toggle(22, 12); toggle(22, 13); toggle(22, 18); toggle(22, 20); toggle(23, 10); toggle(23, 13); toggle(23, 20); toggle(24, 10); toggle(24, 13); toggle(24, 20); toggle(24, 21); toggle(26, 10); toggle(27, 10); toggle(27, 14); toggle(28, 11); toggle(28, 13); toggle(29, 12); toggle(32, 12); toggle(32, 13); toggle(33, 12); toggle(33, 13);
  alwaysResume();
  configSlider();
  enableBorder();
  scrollUp();
}

// Block layers
function minimalState() {
  num_cells = 40; initCanvas(); toggle(16, 19); toggle(18, 18); toggle(18, 19); toggle(20, 15); toggle(20, 16); toggle(20, 17); toggle(22, 14); toggle(22, 15); toggle(22, 16); toggle(23, 15); alwaysResume();
  configSlider();
  disableBorder();
  scrollUp();
}

function fivexfiveState() {
  num_cells = 40; initCanvas(); toggle(16, 16); toggle(16, 17); toggle(16, 20); toggle(17, 16); toggle(17, 19); toggle(18, 16); toggle(18, 19); toggle(18, 20); toggle(19, 18); toggle(20, 16); toggle(20, 18); toggle(20, 19); toggle(20, 20); alwaysResume();
  configSlider();
  disableBorder();
  scrollUp();
}



================================================
FILE: conway_game/simulation.html
================================================
<!DOCTYPE html>
<html lang="en-US">

<head>
  <title>Conway's Game of Life | Visualize It</title>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="keyword" content="conway, conway's game of life, game of life, interactive, automaton">
  <meta name="og:image"
    content="https://github.com/visualize-it/visualize-it.github.io/raw/main/images_webp/conways_game.webp">

  <!-- Materialize -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/js/materialize.min.js"></script>
  <script src="basic.js" defer></script>
  <script src="conway_game.js" defer></script>
  <script src="engine.js" defer></script>
  <script src="predef.js" defer></script>
  <script src="utils.js" defer></script>

  <!-- CSS -->
  <link rel="stylesheet" href="../style.css" />
</head>

<script async src="https://www.googletagmanager.com/gtag/js?id=G-M95CKRP8HB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() { window.dataLayer.push(arguments); }
  gtag('js', new Date());

  gtag('config', 'G-M95CKRP8HB');
</script>

<body>
  <nav class="nav-extended" style="background:black; margin-top: 0mm">
    <div class="nav-wrapper">
      <h1 id="main-heading">Visualize It</h1>
    </div>
    <div class="nav-content">
      <ul class="tabs tabs-transparent tabs-fixed-width">
        <li class="tab"><a href="../index.html" style="font-size: larger;">Home</a></li>
        <li class="tab"><a href="../about.html" style="font-size: larger;">About</a></li>
      </ul>
    </div>
  </nav>
</body>

<div class="text">
  <h2>Conway's Game of Life</h2>

  <center>
    <p>
      The most famous cellular automaton, Conway's game of life was was devised by British Mathematician John Conway in
      1970.
    </p>
  </center>

  <hr>

  <h3>Simulation</h3>

  <p>
    The world consists of a 2D lattice of cells. Each cell has a state, either alive (colored) or dead (black). The
    future of every cell is determined by a simple set of rules:
  <ol>
    <li>An alive cell dies of loneliness if it has none or only 1 living neighbour</li>
    <li>An alive cell dies of starvation if it has more than 3 living neighbours</li>
    <li>An alive cell is sustained if it has 2 or 3 living neighbours</li>
    <li>A non-living cell becomes alive if it has exactly 3 living neighbours</li>
  </ol>
  These rules are enforced on all cells, and the grid is updated synchronously. Cells that are about to die of
  loneliness are represented by white. Cells that are going to die due to
  overcrowding are represented by red. Cells with two neighbours are colored orange whereas cells with three
  neighbours are colored blue.
  </p>
  <b>Instructions: </b>
  <ol>
    <li>Touch a cell in order to toggle its state (dead/alive)</li>
    <li>Toggling a cell's state will automatically pause the simulation. Click on 'Resume' to continue</li>
    <li><b>On mobile phones, avoid touching the canvas while scrolling down</b></li>
  </ol>

  <div class="container" style="width:90%">
    <div class="row">
      <div class="col s12 l8">
        <br>
        <canvas id="canvas"></canvas>
        <br>
      </div>
      <div class="col s12 l4">
        <center>
          <br>
          <button class="btn purple darken-4" id="pause-button" onclick="togglePause()">Pause</button>
          <button class="btn purple darken-4" id="reset-button" onclick="resetCells()">Reset</button>
          <br> <br>
          <button class="btn purple darken-4" id="grid-button" onclick="toggleGrid()">Show Grid</button>
          <br><br>
          <button class="btn purple darken-4" id="border-toggle" onclick="toggleBorder()">Disable border
            interactions</button>
          <br> <br>
          <p id="cell-display">Number of cells per row/column: </p>
          <input id="cell-slider" type="range" min="4" max="40" value="10" oninput="updateParams('cells')"
            onchange="updateParams('cells')" style="width: 80%">
          <br> <br>
          <p id="fps-display">Frames per second:</p>
          <input id="fps-slider" type="range" min="1" max="60" step="1" oninput="updateParams('fps')"
            onchange="updateParams('fps')" style="width: 80%">
        </center>
      </div>
    </div>
  </div>

  <hr>

  <h3>Interesting States</h3>
  <br>

  <div class="container">
    <div class="row">
      <div class="col s12 l6" style="padding:15px;">
        <center>
          <b>Steady States:</b> No change takes place. Every living cell has 2 or 3 neighbours and continues to co-exist
          forever
          <br><br>
          <button class="btn purple darken-4" onclick="beehiveState()">Beehive</button>
          <button class="btn purple darken-4" onclick="loafState()">Loaf</button>
      </div>

      <div class="col s12 l6" style="padding:15px;">
        <center>
          <b>Oscillators:</b> Interchange between the same states periodically
          <br><br>
          <button class="btn purple darken-4" onclick="pentaState()">Penta Decathlon</button>
          <button class="btn purple darken-4" onclick="pulsarState()">Pulsar</button>
        </center>
      </div>
    </div>
    <div class="row">
      <div class="col s12 l6" style="padding:15px;">
        <center>
          <b>Spaceships:</b> Move across the screen and periodically regain their original configuration
          <br><br>
          <button class="btn purple darken-4" onclick="gliderState()">Glider</button>
          <button class="btn purple darken-4" onclick="lwssState()">Small ship</button>
          <button class="btn purple darken-4" onclick="hwssState()">Big ship</button>
        </center>
      </div>
      <div class="col s12 l6" style="padding:15px;">
        <center>
          <b>Methulselahs:</b> Evolve for a long time before stabilizing
          <br> <br>
          <button class="btn purple darken-4" onclick="acornState()">Acorn</button>
          <button class="btn purple darken-4" onclick="diehardState()">Diehard</button>
          <button class="btn purple darken-4" onclick="pentaminoState()">R-pentamino</button>
        </center>
      </div>
    </div>
    <div class="row">
      <div class="col s12 l6" style="padding:15px;">
        <center>
          <b>Glider Guns:</b> Periodically generate an infinite amount of gliders
          <br> <br>
          <button class="btn purple darken-4" onclick="gosperState()">Gosper</button>
          <button class="btn purple darken-4" onclick="simkinState()">Simkin</button>
        </center>
      </div>
      <div class="col s12 l6" style="padding:15px;">
        <center>
          <b>Block layers:</b> Lay down 2x2 blocks as they propagate
          <br> <br>
          <button class="btn purple darken-4" onclick="minimalState()">Minimal</button>
          <button class="btn purple darken-4" onclick="fivexfiveState()">5x5</button>
        </center>
      </div>
    </div>
  </div>

  <hr>

  <h3>Interesting Facts</h3>
  <ol>
    <li>It is possible to construct all elements of electronics in Conway's game of life: logic gates, counters, memory
      cells, etc. In fact, Turing-complete computers have been constructed within this world.</li>
    <li>It is possible to construct self-replicative entities within this game. A DNA-like record has also been used to
      store and propogate information.</li>
    <li>This game can be simulated on a variety of 2D geometric figures like knots and Mobius strips.</li>
    <li>This system also exhibits chaos: if you modify the initial state by a little, then the long-term behaviour of
      the system gets drastically changed.</li>
  </ol>

  <hr>
  <br>

  <b>Note:</b>
  <ol>
    <li>Border interactions can be toggled using the enable/disable border interactions button. Some simulations: like
      the Gosper's glider gun, get interrupted when the Glider wraps around and destroys the gun</li>
    <li>Accidently touching the canvas while scrolling down on a mobile will toggle the state of a cell and may disturb
      the ongoing simulation</li>
  </ol>

  <br>
  <hr>

  <p class="center-align">Developed by ChanRT | Fork me at <a href="https://www.github.com/chanrt">GitHub</a></p>
</div>

</html>


================================================
FILE: conway_game/utils.js
================================================
function resetCells() {
    cells = new2dArray(num_cells);
    neighbours = new2dArray(num_cells);
    next_state = new2dArray(num_cells);
}


function new2dArray(num) {
    array = new Array(num);

    for (let i = 0; i < num; i++) {
        array[i] = new Array(num);
    }

    for (let i = 0; i < num; i++) {
        for (let j = 0; j < num; j++) {
            array[i][j] = 0;
        }
    }
    return array;
}

function prepareNextState() {
    for (let i = 0; i < num_cells; i++) {
        for (let j = 0; j < num_cells; j++) {
            next_state[i][j] = 0;
        }
    }
}

function copyNextState() {
    for (let i = 0; i < num_cells; i++) {
        for (let j = 0; j < num_cells; j++) {
            cells[i][j] = next_state[i][j];
        }
    }
}


================================================
FILE: couzin_model/basic.js
================================================
let screen_width = window.innerWidth, screen_height = window.innerHeight;
let canvas_width, canvas_height;
let fps = 24, paused = false;
let mobile;

if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
    mobile = true;
} else {
    mobile = false;
}

let canvas = document.getElementById("canvas");
let context = canvas.getContext("2d");

let polar_display = document.getElementById("polar-display");
let ang_display = document.getElementById("ang-display");

let num_display = document.getElementById("num-display")

let repulsion_display = document.getElementById("repulsion-display");
let repulsion_input = document.getElementById("repulsion-input");

let orientation_display = document.getElementById("orientation-display");
let orientation_input = document.getElementById("orientation-input");

let attraction_display = document.getElementById("attraction-display");
let attraction_input = document.getElementById("attraction-input");

let moving_speed_display = document.getElementById("moving-speed-display");
let moving_speed_input = document.getElementById("moving-speed-input");

let turning_speed_display = document.getElementById("turning-speed-display");
let turning_speed_input = document.getElementById("turning-speed-input");

let noise_display = document.getElementById("noise-display");
let noise_input = document.getElementById("noise-input");

let blind_display = document.getElementById("blind-display");
let blind_input = document.getElementById("blind-input");

let reflect_button = document.getElementById("reflect-button");
let pause_button = document.getElementById("pause-button");

if (mobile) {
    canvas_width = 0.9 * screen_width;
}
else {
    canvas_width = 0.45 * screen_width;
}
canvas_height = canvas_width;

canvas.width = canvas_width;
canvas.height = canvas_height;

let animate = window.requestAnimationFrame
    || window.webkitRequestAnimationFrame
    || window.mozRequestAnimationFrame
    || function (callback) {
        window.setTimeout(callback, 1000 / fps);
    };

function step() {
    if (!paused) {
        update();
    }
    render();
    animate(step);
}

window.onload = function () {
    defaultParams();
    initParams();
    animate(step);
}

function defaultParams() {
    if (mobile) {
        spoke_length = 5;
        characteristic_length = 8;
    }
    else {
        spoke_length = 8;
        characteristic_length = 12;
    }

    repulsion_input.value = 1;
    orientation_input.value = 3;
    attraction_input.value = 15;

    moving_speed_input.value = 7;
    turning_speed_input.value = 8;
    noise_input.value = 10;

    blind_input.value = 90;
    reflect = false;

    if (reflect == false) {
        reflect_button.innerHTML = "Reflect: Off";
    }
    else {
        reflect_button.innerHTML = "Reflect: On";
    }
}

let click_x, click_y, pressed;

if(mobile) {
    canvas.addEventListener("touchstart", function (e) {
        getTouchPosition(canvas, e);
        let touch = e.touches[0];
        let mouseEvent = new MouseEvent("mousedown", {
            clientX: touch.clientX,
            clientY: touch.clientY
        });
        canvas.dispatchEvent(mouseEvent);
        pressed = true;
        clicked();
    }, false);

    canvas.addEventListener("touchmove", function (e) {
        getTouchPosition(canvas, e);
        let touch = e.touches[0];
        let mouseEvent = new MouseEvent("mousemove", {
            clientX: touch.clientX,
            clientY: touch.clientY
        });
        canvas.dispatchEvent(mouseEvent);
        moved();
    }, false);

    canvas.addEventListener("touchend", function (e) {
        getTouchPosition(canvas, e);
        let touch = e.touches[0];
        let mouseEvent = new MouseEvent("mouseup", {
            clientX: touch.clientX,
            clientY: touch.clientY
        });
        canvas.dispatchEvent(mouseEvent);
        pressed = false;
        released();
    }, false);
}
else {
    canvas.addEventListener("mousedown", function (e) {
        getMousePosition(canvas, e);
        pressed = true;
        clicked();
    });

    canvas.addEventListener("mousemove", function (e) {
        getMousePosition(canvas, e);
        moved();
    });

    canvas.addEventListener("mouseup", function (e) {
        getMousePosition(canvas, e);
        pressed = false;
        released();
    });

    window.addEventListener("keydown", function(e) {
        keyPressed(e.keyCode);
    }, false);

    window.addEventListener("keydown", function(e) {
        keyReleased(e.keyCode);
    }, false);
}

function getMousePosition(canvas, event) {
    rect = canvas.getBoundingClientRect();
    click_x = event.clientX - rect.left;
    click_y = event.clientY - rect.top;
}

function getTouchPosition(canvas, event) {
    var rect = canvas.getBoundingClientRect();
    click_x = event.touches[0].clientX - rect.left;
    click_y = event.touches[0].clientY - rect.top;
}

function pauseToggle() {
    if (paused) {
        paused = false;
        pause_button.innerHTML = "Pause";
    }
    else {
        paused = true;
        pause_button.innerHTML = "Resume";
    }
}

function toggleReflection() {
    if (reflect) {
        reflect = false;
        reflect_button.innerHTML = "Reflect: Off";
    }
    else {
        reflect = true;
        reflect_button.innerHTML = "Reflect: On";
    }
}


================================================
FILE: couzin_model/Boid.js
================================================
class Boid {
    constructor(position, velocity) {
        this.position = position;
        this.velocity = velocity;
        this.req_velocity = velocity;
    }

    setVelocity(velocity) {
        this.req_velocity = velocity;
    }

    updateVelocity() {
        let angle = Math.atan2(this.req_velocity.y, this.req_velocity.x) - Math.atan2(this.velocity.y, this.velocity.x);
        while (angle > Math.PI) {
            angle -= 2 * Math.PI;
        }
        while (angle < -Math.PI) {
            angle += 2 * Math.PI;
        }

        if (angle > turning_speed) {
            angle = turning_speed;
        }
        else if (angle < -turning_speed) {
            angle = -turning_speed;
        }

        let rotation_matrix = [
            [Math.cos(angle), -Math.sin(angle)],
            [Math.sin(angle), Math.cos(angle)]
        ];
        this.velocity.x = rotation_matrix[0][0] * this.velocity.x + rotation_matrix[0][1] * this.velocity.y;
        this.velocity.y = rotation_matrix[1][0] * this.velocity.x + rotation_matrix[1][1] * this.velocity.y;
        this.velocity.normalize();
    }

    update() {
        // update position
        this.position.x += moving_speed * this.velocity.x
        this.position.y += moving_speed * this.velocity.y;

        if (this.position.x < 0) {
            this.position.x = 0;
            this.velocity.x *= -1;
        }
        else if (this.position.x > canvas_width) {
            this.position.x = canvas_width;
            this.velocity.x *= -1;
        }
        if (this.position.y < 0) {
            this.position.y = 0;
            this.velocity.y *= -1;
        }
        else if (this.position.y > canvas_height) {
            this.position.y = canvas_height;
            this.velocity.y *= -1;
        }

        this.direction = this.velocity.getHeading();
    }

    render() {
        context.fillStyle = "#ffffff";
        context.beginPath();
        context.moveTo(this.position.x + spoke_length * Math.cos(this.direction), this.position.y + spoke_length * Math.sin(this.direction));
        context.lineTo(this.position.x + spoke_length * Math.cos(this.direction + spoke_angle), this.position.y + spoke_length * Math.sin(this.direction + spoke_angle));
        context.lineTo(this.position.x + spoke_length * Math.cos(this.direction - spoke_angle), this.position.y + spoke_length * Math.sin(this.direction - spoke_angle));
        context.lineTo(this.position.x + spoke_length * Math.cos(this.direction), this.position.y + spoke_length * Math.sin(this.direction));
        context.fill();
    }
}


================================================
FILE: couzin_model/predefs.js
================================================
function swarm() {
    num_boids = 100;

    repulsion_input.value = 1;
    orientation_input.value = 1;
    attraction_input.value = 15;

    moving_speed_input.value = 3;
    turning_speed_input.value = 8;
    noise_input.value = 10;

    blind_input.value = 90;
    reflect = false;

    if (reflect == false) {
        reflect_button.innerHTML = "Reflect: Off";
    }
    else {
        reflect_button.innerHTML = "Reflect: On";
    }

    initParams();
    window.scrollTo(0, 300);
}

function swirl() {
    num_boids = 100;

    repulsion_input.value = 1;
    orientation_input.value = 3;
    attraction_input.value = 15;

    if (mobile) {
        moving_speed_input.value = 5;
    }
    else {
        moving_speed_input.value = 7;
    }
    turning_speed_input.value = 8;
    noise_input.value = 10;

    blind_input.value = 90;
    reflect = false;

    if (reflect == false) {
        reflect_button.innerHTML = "Reflect: Off";
    }
    else {
        reflect_button.innerHTML = "Reflect: On";
    }

    initParams();
    window.scrollTo(0, 300);
}

function dynamicParallel() {
    num_boids = 2;

    repulsion_input.value = 1;
    orientation_input.value = 6;
    attraction_input.value = 7;

    moving_speed_input.value = 3;
    turning_speed_input.value = 4;
    noise_input.value = 10;

    blind_input.value = 90;
    reflect = false;

    if (reflect == false) {
        reflect_button.innerHTML = "Reflect: Off";
    }
    else {
        reflect_button.innerHTML = "Reflect: On";
    }

    initParams();
    window.scrollTo(0, 300);
}

function highlyParallel() {
    num_boids = 100;

    repulsion_input.value = 1;
    orientation_input.value = 12;
    attraction_input.value = 15;

    moving_speed_input.value = 3;
    turning_speed_input.value = 4;
    noise_input.value = 2;

    blind_input.value = 90;
    reflect = false;

    if (reflect == false) {
        reflect_button.innerHTML = "Reflect: Off";
    }
    else {
        reflect_button.innerHTML = "Reflect: On";
    }

    initParams();
    window.scrollTo(0, 300);
}


================================================
FILE: couzin_model/simulation.html
================================================
<!DOCTYPE html>
<html lang="en-US">

<head>
  <title>Collective Behaviour | Visualize It</title>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="keyword"
    content="collective behaviour, flocking behaviour, interactive, boids, boids simulation, couzin model">
  <meta name="og:image"
    content="https://github.com/visualize-it/visualize-it.github.io/raw/main/images_webp/collective_behaviour.webp">

  <!-- Materialize -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/js/materialize.min.js"></script>

  <script src="utils.js" defer></script>
  <script src="basic.js" defer></script>
  <script src="user_input.js" defer></script>
  <script src="Vector.js" defer></script>
  <script src="Boid.js" defer></script>
  <script src="tests.js" defer></script>
  <script src="predefs.js" defer></script>
  <script src="simulation.js" defer></script>


  <script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML">
    </script>

  <!-- CSS -->
  <link rel="stylesheet" href="../style.css" />
</head>

<script async src="https://www.googletagmanager.com/gtag/js?id=G-M95CKRP8HB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() { window.dataLayer.push(arguments); }
  gtag('js', new Date());

  gtag('config', 'G-M95CKRP8HB');
</script>

<body>
  <nav class="nav-extended" style="background:black; margin-top: 0mm">
    <div class="nav-wrapper">
      <h1 id="main-heading">Visualize It</h1>
    </div>
    <div class="nav-content">
      <ul class="tabs tabs-transparent tabs-fixed-width">
        <li class="tab"><a href="../index.html" style="font-size: larger;">Home</a></li>
        <li class="tab"><a href="../about.html" style="font-size: larger;">About</a></li>
      </ul>
    </div>
  </nav>
</body>

<div class="text">
  <h2>Collective Behaviour</h2>

  <center>
    <p>Basic interactions like repulsion, orientation and attraction can operate to different extents and give rise to a
      variety of dynamical behaviours.</p>
  </center>

  <div class="container" style="width: 90%">
    <div style="background:black; padding: 15px; border: 2px red solid;">
      <center>
        <b>This real-time simulation is computationally complex and may induce unresponsiveness
          on lower-end devices</b>
      </center>
    </div>
    <br>

    <div class="row">
      <div class="col s12 l7">
        <canvas id="canvas"></canvas>
        <br>
      </div>
      <div class="col s12 l5">
        <center>
          <span class="jittery" id="polar-display"></span> <br>
          <span class="jittery" id="ang-display">Group angular momentum: </span>
          <hr>
          <p id="num-display"></p>
          <button class="btn purple darken-4" onclick="addBoids()">Add</button>
          <button class="btn purple darken-4" onclick="removeBoids()">Remove</button>
          <button class="btn purple darken-4" onclick="clearBoids()">Clear</button>
          <hr>
          <div class="col s12 l6">
            <span id="repulsion-display"></span>
            <input id="repulsion-input" type="range" min="0.5" max="5" step="0.1" oninput="updateParams('repulsion')"
              onchange="updateParams('repulsion')">

            <span id="orientation-display"></span>
            <input id="orientation-input" type="range" min="1" max="15" step="0.2" oninput="updateParams('orientation')"
              onchange="updateParams('orientation')">

            <span id="attraction-display"></span>
            <input id="attraction-input" type="range" min="1" max="15" step="0.2" oninput="updateParams('attraction')"
              onchange="updateParams('attraction')">
          </div>
          <div class="col s12 l6">
            <span id="moving-speed-display"></span>
            <input id="moving-speed-input" type="range" min="1" max="10" step="0.2"
              oninput="updateParams('moving-speed')" onchange="updateParams('moving-speed')">

            <span id="turning-speed-display"></span>
            <input id="turning-speed-input" type="range" min="0" max="20" step="1"
              oninput="updateParams('turning-speed')" onchange="updateParams('turning-speed')">

            <span id="noise-display"></span>
            <input id="noise-input" type="range" min="0" max="20" step="1" oninput="updateParams('noise')"
              onchange="updateParams('noise')">
          </div>

          <hr>

          <div class="col s12 l6">
            <span id="blind-display"></span>
            <input id="blind-input" type="range" min="0" max="270" step="10" oninput="updateParams('blind')"
              onchange="updateParams('blind')">
          </div>

          <div class="col s12 l6">
            <button id="reflect-button" class="btn purple darken-4" onclick="toggleReflection()"
              style="margin-top: 20px;">Reflection: On</button>
          </div>

          <hr>

          <button id="pause-button" onclick="pauseToggle()" class="btn purple darken-4">Pause</button>
          <button onclick="initParams()" class="btn purple darken-4">Restart</button>

        </center>
      </div>
    </div>
  </div>

  <hr>

  <h3>Interactions</h3>

  <p>All boids (a generic term used to indicate agents in collective behaviour) interact with each other via three
    interactions:</p>

  <ol>
    <li>
      <b>Repulsion:</b> <br>
      When boids come too close, they move away from each other. Suppose there are \(n_r\) boids within the repulsion
      radius of a particular boid \(i\). If \(\vec{d}\) represents their direction, and
      \(\vec{c}\) represents their position, then repulsion dictates:
      \[ \vec{d}_{i, r} (t + \tau) = - \sum_{j \not = i}^{n_r} \frac{\vec{c}_j (t) - \vec{c}_i (t)}{|\vec{c}_j (t) -
      \vec{c}_i (t)|} \]
    </li>
    <li>
      <b>Orientation:</b> <br>
      Boids tend to orient themselves along the direction of their neighbours. Suppose there are \(n_o\) boids within
      the orientation radius of a particular boid \(i\). If \(\vec{v}\) represents their velocity, then orientation
      dictates:
      \[ \vec{d}_{i, o} (t + \tau) = \sum_{j = 1}^{n_o} \frac{\vec{v_j} (t)}{|\vec{v_j} (t) |}\]
    </li>
    <li>
      <b>Attraction:</b> <br>
      Boids tend to move towards the centre of mass of their neighbours. Suppose there are \(n_a\) boids within the
      attraction radius of a particular boid \(i\). then attraction operates exactly opposite to orientation:
      \[ \vec{d}_{i, a} (t + \tau) = \sum_{j = 1}^{n_r} \frac{\vec{c}_j (t) - \vec{c}_i (t)}{|\vec{c}_j (t) -
      \vec{c}_i (t)|} \]
    </li>
  </ol>

  <p>
    If there are any boids in the repulsion zone of a boid, then the boid only follows the repulsion rule. If there are
    boids that lie in the attraction as well as the orientation zone, then the boid averages the result of both
    interactions. The boids can turn only at a limited angle \( \theta \) in every time step. Further, there is a blind
    angle \( \alpha \) behind each boid where it cannot perceive other boids. Every boid moves with the same velocity
    \(v\) along its current direction. The intended direction of every boid is perturbed by random noise. This
    represents errors in judgement made by the boids.
  </p>

  <hr>

  <h3>Metrics</h3>

  <p>
    The following quantities can be used to quantify the collective motion of boids:
  </p>

  <ol>
    <li>
      <b>Group polarization:</b> <br>
      This quantifies the degree of overall alignment of the boids. If every boid is moving along the same direction,
      then group polarization is 1. If all boids are moving along random directions, then group polarization is 0.
      \[ p (t) = \frac{1}{N} \left| \sum_{i}^{N} \vec{v}_i (t) \right| \]
    </li>
    <li>
      <b>Group angular momentum:</b> <br>
      Measures the degree of rotation of the group along their center:
      \[ m (t) = \frac{1}{N} \left| \sum_{i}^{N} \vec{r}_{ic} (t) \times \vec{v}_i (t) \right| \]
      Here, \( \vec{r}_{ic} = \vec{c}_i - \vec{c}_{group} \) is the displacement vector of the \(i^{th}\) boid from the
      center of mass of the group, which is given by:
      \[ \vec{c}_{group} (t) = \sum_{i = 1}^{N} \vec{c}_{i} (t) \]
    </li>
  </ol>

  <hr>

  <h3>Dynamical Behaviours</h3>

  <p>
    Depending on the strengths of various interactions, as well as other parameters, the boids can exhibit four
    different kinds of dynamical behaviour:
  </p>

  <ol>
    <li>
      <b>Swarming:</b> <br>
      Characterised by low polarization and low angular momentum <br>
      This behaviour is seen when attraction is the dominant force, and there is negligible orientation. Boids rotate in
      random directions, repeatedly flying into the center of the group and then emerging out. This sort of
      behaviour is often seen in insects.
      <br> <br>
      <center>
        <button class="btn purple darken-4" onclick="swarm()">Observe</button>
      </center>
    </li>
    <br>
    <li>
      <b>Swirling:</b> <br>
      Characterised by low polarization and high angular momentum <br>
      This behaviour is observed when orientation is low whereas attraction is relatively high. Boids
      revolve around a common point in the same direction. This behaviour is seen in fish. <br>
      <b>It may take some time for swirls to emerge</b>.
      <br> <br>
      <center>
        <button class="btn purple darken-4" onclick="swirl()">Observe</button>
      </center>
    </li>
    <br>
    <li>
      <b>Dynamic parallel grouping:</b> <br>
      Characterised by high polarisation and low angular momentum <br>
      This behaviour is observed when orientation is intermediate whereas attraction can be either intermediate or
      relatively high. Boids move in groups called 'flocks'. Seen in birds and fish.
      <br> <br>
      <center>
        <button class="btn purple darken-4" onclick="dynamicParallel()">Observe</button>
      </center>
    </li>
    <br>
    <li>
      <b>Highly parallel grouping:</b> <br>
      Characterised by very high polarisation and low angular momentum <br>
      This behaviour is seen when orientation is high. <br>
      <b>It may take some time for highly parallel groupings to emerge</b>.
      <br> <br>
      <center>
        <button class="btn purple darken-4" onclick="highlyParallel()">Observe</button>
      </center>
    </li>
  </ol>


  <br>
  <hr>
  <br>

  <b>Note:</b>

  <ol>
    <li>
      This model is from the paper "Collective Memory and Spatial Sorting in Animal Groups" by Couzin et al. <a
        href="https://doi.org/10.1006/jtbi.2002.3065">https://doi.org/10.1006/jtbi.2002.3065</a>
    </li>
    <li>
      If reflect is off, boids just teleport from one edge to another. Implementing a periodic boundary condition was
      not possible owing to the complex nature of this simulation
    </li>
    <li>
      Although this simulation is usable on a mobile, it is preferably viewed on a desktop.
    </li>
    <li>
      Related: <a href="../firefly_synchronization/simulation.html">Firefly Synchronization</a>,
      <a href="../vicsek_model/simulation.html">Vicsek Model</a>, <a
        href="../pedestrian_dynamics/simulation.html">Pedestrian Dynamics</a>.
    </li>
  </ol>

  <hr>

  <p class="center-align">Developed by ChanRT | Fork me at <a href="https://www.github.com/chanrt">GitHub</a></p>
</div>

</html>


================================================
FILE: couzin_model/simulation.js
================================================
// objects
let boids = [];
let num_boids = 100;

// speeds
let moving_speed = 3;
let turning_speed = 8;

// lengths
let characteristic_length;
let repulsion_radius, orientation_radius, attraction_radius;

// angles
let blind_angle;
let half_visible_angle = Math.PI - blind_angle / 2;
let noise_angle;

// states
let reflect;

// misc
let boid_step = 5;

// cosmetic
let spoke_length;
let spoke_angle = toRadian(150);

function update() {
    for (let boid of boids) {
        let repelling_boids = getBoidsWithin(boid, repulsion_radius * characteristic_length);

        if (repelling_boids.length > 0) {
            // repulsion
            let repelling_vector_sum = new Vector(0, 0);

            for (let repelling_boid of repelling_boids) {
                let repelling_vector = Vector.subtract(repelling_boid.position, boid.position);
                repelling_vector_sum.add(Vector.normalize(repelling_vector));
            }

            repelling_vector_sum.negate();
            repelling_vector_sum.normalize();

            boid.setVelocity(repelling_vector_sum);
        }
        else {
            let orienting_boids = getBoidsWithin(boid, orientation_radius * characteristic_length);
            let attracting_boids = getBoidsWithin(boid, attraction_radius * characteristic_length);

            // orientation
            let orienting_vector_sum = new Vector(0, 0);
            for (let orienting_boid of orienting_boids) {
                let orienting_vector = orienting_boid.velocity;
                orienting_vector_sum.add(orienting_vector);
            }
            orienting_vector_sum.normalize();

            // attraction
            let attracting_vector_sum = new Vector(0, 0);
            for (let attracting_boid of attracting_boids) {
                let attracting_vector = Vector.subtract(attracting_boid.position, boid.position);
                attracting_vector_sum.add(Vector.normalize(attracting_vector));
            }
            attracting_vector_sum.normalize();

            if (orienting_boids.length > 0 && attracting_boids.length == 0) {
                boid.setVelocity(orienting_vector_sum);
            }
            else if (attracting_boids.length > 0 && orienting_boids.length == 0) {
                boid.setVelocity(attracting_vector_sum);
            }
            else if (orienting_boids.length > 0 && attracting_boids.length > 0) {
                orienting_vector_sum.scale(0.5);
                attracting_vector_sum.scale(0.5);
                let required_velocity = Vector.add(orienting_vector_sum, attracting_vector_sum);
                required_velocity.normalize();
                boid.setVelocity(required_velocity);
            }
        }
    }

    let polarization_sum = new Vector(0, 0);
    for (let boid of boids) {
        polarization_sum.add(boid.velocity);
    }
    let group_polarization = polarization_sum.magnitude() / num_boids;
    polar_display.innerHTML = `Group polarization: ${group_polarization.toFixed(2)}`;

    let position_sum = new Vector(0, 0);
    for (let boid of boids) {
        position_sum.add(boid.positio